<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[科技文档写作实务]]></title>
    <url>%2F2018%2F03%2F06%2F%E7%A7%91%E6%8A%80%E6%96%87%E6%A1%A3%E5%86%99%E4%BD%9C%E5%AE%9E%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[中兴通讯学院编著 产品需要全生命周期的管理，贯穿其中的是科技文档，依靠科技文档实现在不同环节的知识传递和产品价值链的耦合，在企业与市场间架起桥梁。 概述篇什么是技术文档技术文档写作的国内国际现状技术文档写作的重要意义基础篇技术文档写作流程需求分析架构设计文档写作质量控制进阶篇实用性可读性舒适性实战篇研发文档实战如何写需求说明书如何写概要设计文档如何写软件模块详细设计文档如何编写测试用例用户文档实战如何写使用指导文档如何写故障处理文档]]></content>
      <categories>
        <category>读书记</category>
      </categories>
      <tags>
        <tag>technical writing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R-3]]></title>
    <url>%2F2018%2F03%2F03%2FR-3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[R-2]]></title>
    <url>%2F2018%2F03%2F02%2FR-2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[R-1]]></title>
    <url>%2F2018%2F02%2F28%2FR-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[R-note]]></title>
    <url>%2F2018%2F02%2F22%2FR-note%2F</url>
    <content type="text"></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2018%2F02%2F09%2FDjango%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[requests-moyanmovie]]></title>
    <url>%2F2018%2F02%2F02%2Frequests-moyanmovie%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之Selenium]]></title>
    <url>%2F2018%2F01%2F31%2F07-Selenium%2F</url>
    <content type="text"><![CDATA[什么是Selenium自动化测试工具，支持多种浏览器。爬虫中主要用来解决JavaScript渲染的问题。 基本使用12345678910111213141516171819from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Firefox()try: browser.get('https://www.baidu.com') input = browser.find_element_by_id('kw') input.send_keys('Python') input.send_keys(Keys.ENTER) wait = WebDriverWait(browser,10) wait.until(EC.presence_of_element_located((By.ID,('content_left'))) print(browser.current_url) print(browser.get_cookies()) print(browser.page_source)finally: browser.close() 查找元素]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之PyQuery]]></title>
    <url>%2F2018%2F01%2F31%2F06-PyQuery%2F</url>
    <content type="text"><![CDATA[PyQuery正则太麻烦？BeautifulSoup语法太难记？PyQuery 是一个好选择。 初始化字符串初始化123from pyquery import PyQuery as pqdoc = pq(html)print(doc('li')) URL初始化123from pyquery import PyQuery as pqdoc = pq(url='http://baidu.com')print(doc('head')) 文件初始化123from pyquery import PyQuery as pqdoc = pq(filename='demo.html')print(doc('li')) 基本CSS选择器123from pyquery import PyQuery as pqdoc = pq(html)print(doc('#container .list.li')) #空格表示嵌套关系 查找元素子元素12345678from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')print(type(items))print(items)lis = items.find('li')print(type(lis))print(lis) 父元素]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之BeautifulSoup]]></title>
    <url>%2F2018%2F01%2F30%2F05-BeautifulSoup%2F</url>
    <content type="text"><![CDATA[BeautifulSoup灵活方便的网页解析库，处理高校，支持多种解析器。利用它不用编写正则表达式即可方便地实现网页信息的提取。 用法解析库 解析器 使用方法 Python标准库 BeautifulSoup(markup,’html.parser’) lxml HTML解析器 BeautifulSoup(markup,’lxml’) lxml XML解析器 BeautifulSoup(markup,’xml’) html5lib BeautifulSoup(markup,’html5lib’) 基本使用1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.prettify()) #自动格式化代码print(soup.title.string) 标签选择器选择元素123456from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.title) #选择title标签print(type(soup.title)) #查看title标签的类型print(soup.head)print(soup.p) #只输出第一个匹配结果 获取名称123from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.title.name) 获取属性1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.attrs['name'])print(soup.p['name']) 获取内容123from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.p.string) 嵌套选择123from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.head.title.string) 子节点和子孙节点123from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.p.contents) #列表类型 12345from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.p.childen) #迭代器子节点for i,child in ennumerate(soup.p.childen): print(i,child) 12345from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.p.descendants) #迭代器子孙节点for i,child in ennumerate(soup.p.descendants): print(i,child) 父节点和祖先节点123from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.a.parent) #a标签的父节点输出 123from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(list(ennumerate(soup.a.parents))) #a标签的祖先节点输出 兄弟节点1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(list(ennumerate(soup.a.next_siblings))) #a标签的后兄弟节点输出print(list(ennumerate(soup.a.previous_siblings))) #a标签的前兄弟节点输出 标准选择器find_all(name,attrs,recusive,text)总结 推荐使用lxml解析库 标签选择筛选功能弱但是速度快 使用find()或find_all()查询匹配单个结果或多个结果 如果对CSS选择器熟悉就用select() 记住常用的获取属性和文本值的方法]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之正则表达式]]></title>
    <url>%2F2018%2F01%2F30%2F04-regular-expressions%2F</url>
    <content type="text"><![CDATA[什么是正则表达式用事先定义好的一些特定字符及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 re模块 re.match从第一字符匹配 最常规的匹配泛匹配.* group 匹配目标使用括号得到匹配目标 贪婪匹配非贪婪匹配尽量使用非贪婪模式 注：有换行符就用re.S 转义\ re.search扫描整个字符串并返回第一个成功匹配。 注：为匹配方便，能用search就不用match re.findall搜索字符串，以列表形式返回全部能匹配的子串。 re.sub替换字符串中每一个匹配的子串后返回替换后的字符。re.compile将正则字符串编译成正则表达式对象。 代码复用。 实战练习豆瓣读书页面爬取。 123456789101112import requsetsimport recontent = requests.get('https://book.douban.com/').textpattern - re.compile('&lt;li.*?cover.*？href=“(.*?)”.*?title="(.*?)".*?more-meta.*?author"&gt;(.*?)&lt;/span&gt;.*?year"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;',re.S)results = re.findall(pattern,content)print(results)for result in results: url,name,author,date = result print(url,name,author,date.strip())# 或用re.sub方法# author = re.sub('\s','',author)# data = re.sub('\s','',date)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之requests]]></title>
    <url>%2F2018%2F01%2F30%2F03-requests%2F</url>
    <content type="text"><![CDATA[什么是 RequestsRequests 基于 urllib，采用Apache2 License 开源协议的HTTP库。 Python实现的简单易用的HTTP库。 基本操作1234567import requestsresponse = requests.get（'http://www.baidu.com/'）print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之urllib库]]></title>
    <url>%2F2018%2F01%2F26%2F02-urllib%2F</url>
    <content type="text"><![CDATA[什么是UrllibPython内置的HTTP请求库 urllib.request 请求模块 urllib.error 异常处理模块 urllib.parse url解析模块 urllib.robotparser robots.txt 异常处理模块 基本用法urlopenurllib.request.urlopen(url) eg.(GET)：123import urllib.requestresponse = urllib.request.urlopen('http://www.baidu.com')print(response.read().decode('utf-8')) eg.(POST):12345import urllib.parseimport urllib.requestdata = bytes(urllib.parse.urlencode(&#123;'word':'hello'&#125;),encoding='utf8')response = urllib.request.urlopen('http://httpbin.org/post',data=data)print(response.read()) eg.(超时)：123import urllib.requestresponse = urllib.request.urlopen('http://httpbin.org/post',timeout=1)print(response.read())]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之爬虫基本原理]]></title>
    <url>%2F2018%2F01%2F26%2F01-principalOfCrawler%2F</url>
    <content type="text"><![CDATA[什么是爬虫请求网站并提取数据的自动化程序 爬虫基本流程发起请求Request 请求方式 GET POST 请求URL 请求头 请求体 获取响应内容Response 响应状态 响应头 响应体 解析内容 网页文本：HTML/Json格式文本等 图片格式 二进制抓取 视频 二进制抓取 解析方式 直接处理 Json解析 正则表达式 BeautifulSoup PyQuery Xpath 怎样解决JS渲染问题 分析Ajax请求 Json字符串 Selenium/WebDriver Splash PyV8，Ghostpy 保存数据 文本 关系型数据库，如MySQL，Oracle等 非关系型数据库，如MongoDB，Redis等Key-Value型数据库 二进制文件]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 Selenium 调用 Firefox 报错]]></title>
    <url>%2F2018%2F01%2F26%2Fpython-selenium%2F</url>
    <content type="text"><![CDATA[通过selenium 调用 webdriver 操控 Firefox： 12from selenium import webdriverdriver = webdriver.Firefox() 发现报错： 123456789101112131415161718Traceback (most recent call last): File "/usr/local/lib/python3.5/dist-packages/selenium/webdriver/common/service.py", line 76, in start stdin=PIPE) File "/usr/lib/python3.5/subprocess.py", line 947, in __init__ restore_signals, start_new_session) File "/usr/lib/python3.5/subprocess.py", line 1551, in _execute_child raise child_exception_type(errno_num, err_msg)FileNotFoundError: [Errno 2] No such file or directory: 'geckodriver'During handling of the above exception, another exception occurred:Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/local/lib/python3.5/dist-packages/selenium/webdriver/firefox/webdriver.py", line 148, in __init__ self.service.start() File "/usr/local/lib/python3.5/dist-packages/selenium/webdriver/common/service.py", line 83, in start os.path.basename(self.path), self.start_error_message)selenium.common.exceptions.WebDriverException: Message: 'geckodriver' executable needs to be in PATH. Google找到解决方案，在github上下载geckodriver： 1234sudo tar zxvf geckodriver-v0.19.1-linux32.tar.gz # 下载geckodriver并解压缩sudo mv geckodriver /usr/bin/ # 将geckodriver移动到bin目录下cd /usr/bin/ # 进入bin目录sudo chmod +x geckodriver # 获取权限 这时再调用Firefox，发现可以成功跳转网页: 123from selenium import webdriver driver = webdriver.Firefox()driver.get('http://www.zhihu.com')]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《金字塔原理》]]></title>
    <url>%2F2018%2F01%2F23%2F%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[豆瓣 mark 这本书很久了，正巧赶上淘宝打折，果断下单，又花了两天把书撸完。 整本书逻辑框架十分清晰，我这种菜鸟新手整个看的过程也很流畅，作为入门书籍非常棒，从实用的例子来练习熟悉，章节顺序安排合理，跟着练下来可以信心十足的明确自己会做哪些，还能做哪些。包括最开始介绍的如何排查错误，其思路也可以运用到很多事物上。]]></content>
      <categories>
        <category>读书记</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web-server]]></title>
    <url>%2F2018%2F01%2F23%2Fweb-server%2F</url>
    <content type="text"><![CDATA[HTTP协议]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>server</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP 和 TCP 那点事儿]]></title>
    <url>%2F2018%2F01%2F22%2Fnetwork-tcpip%2F</url>
    <content type="text"><![CDATA[小时候最流行单机游戏，两个人，两个手柄，打到通关。后来网络把世界连接到了一起，让在不同的电脑上的软件和不同地区的人能够进行数据传递，在《计算机网络》中我们把它称作为进程之间的通信。 那么不同种类之间的计算机到底是怎么进行数据传递的呢？就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，这个计算机都遵守的网络通信协议就是 ‘TCP/IP协议’ 。 TCP/IP协议(族)早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容,为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。 因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。 端口那么TCP/IP协议中的端口指的是什么呢？端口就好一个房子的门，是出入这间房子的必经之路。 如果一个进程需要收发网络数据，那么就需要有这样的端口，在linux系统中，端口可以有65536（2的16次方）个之多！ 端口号既然有这么多，操作系统为了统一管理，所以进行了编号，这就是端口号。 知名端口知名端口是众所周知的端口号，范围从0到1023，例如： 80端口分配给HTTP服务 21端口分配给FTP服务 动态端口动态端口的范围是从1024到65535，之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。 动态分配是指当一个系统进程或应用程序进程需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。 当这个进程关闭时，同时也就释放了所占用的端口号。 UDPUDP — 用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。 UDP 特点UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。 UDP 应用场景UDP是面向消息的协议，通信时不需要建立连接，数据的传输自然是不可靠的，UDP一般用于多点通信和实时的数据业务，比如: 语音广播 视频 QQ TFTP(简单文件传送） SNMP（简单网络管理协议） RIP（路由信息协议，如报告股票市场，航空信息） DNS(域名解释） UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。 udp网络程序-发送、接受数据创建一个udp客户端程序的流程是简单，具体步骤如下： 创建客户端套接字 发送/接收数据 关闭套接字 发送代码如下： 123456789101112131415161718#coding=utf-8from socket import *#1. 创建套接字udpSocket = socket(AF_INET, SOCK_DGRAM)#2. 准备接收方的地址sendAddr = ('192.168.1.103', 8080)#3. 从键盘获取数据sendData = raw_input("请输入要发送的数据:")#4. 发送数据到指定的电脑上udpSocket.sendto(sendData, sendAddr)#5. 关闭套接字udpSocket.close() 接收代码如下： 123456789101112131415161718192021222324#coding=utf-8from socket import *#1. 创建套接字udpSocket = socket(AF_INET, SOCK_DGRAM)#2. 准备接收方的地址sendAddr = ('192.168.1.103', 8080)#3. 从键盘获取数据sendData = raw_input("请输入要发送的数据:")#4. 发送数据到指定的电脑上udpSocket.sendto(sendData, sendAddr)#5. 等待接收对方发送的数据recvData = udpSocket.recvfrom(1024) # 1024表示本次接收的最大字节数#6. 显示对方发送的数据print(recvData)#7. 关闭套接字udpSocket.close()]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>udp</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template render error - unknown block tag cq]]></title>
    <url>%2F2018%2F01%2F15%2FTemReError%2F</url>
    <content type="text"><![CDATA[最近想给博客换个theme，装新主题的过程中deploy忽然崩错，错误如下： 1234INFO Start processingFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 5, Column 3]unknown block tag: cq 因为之前只修改过主题和配置文件，所以一直以为是主题下文件出了问题，就从主题下手，把新clone下来的主题删掉，发现不可行，依然崩错，遂Google。StackOverflow上有相同问题，看解答是md文件出了错，cq这个tag用错了导致渲染失败，所以把所有post剪切掉，再编译，错误变了： 1234INFO Start processingFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path)Error: Unable to call `the return value of (posts[&quot;first&quot;])[&quot;updated&quot;][&quot;toISOString&quot;]`, which is undefined or falsey 应该是post全被删除的缘故，所以进行部分post调试，终于找到了问题post，删掉了问题post的cq标签，编译成功。 不过还是不知道为什么忽然就编译失败，这篇出问题post已经发了几个月，之前deploy一直没有出现过问题，猜想可能是因为所用标签除了next主题其他都无法渲染。 所以只想简单换个主题，结果又是一个下午的找bug……sigh]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 数据操作]]></title>
    <url>%2F2018%2F01%2F14%2FRedis%2F</url>
    <content type="text"><![CDATA[redis是key-value的数据，所以每个数据都是一个键值对 键的类型是字符串 值的类型分为五种： 字符串string 哈希hash 列表list 集合set 有序集合zset 数据操作的全部命令，可以查看中文网站]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 基本操作和高级操作]]></title>
    <url>%2F2018%2F01%2F13%2FMongoDB%2F</url>
    <content type="text"><![CDATA[MongoDB特点 模式自由 :可以把不同结构的文档存储在同一个数据库里 面向集合的存储：适合存储 JSON风格文件的形式 完整的索引支持：对任何属性可索引 复制和高可用性：支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目的是提供冗余及自动故障转移 自动分片：支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器 丰富的查询：支持丰富的查询表达方式，查询指令使用JSON形式的标记，可轻易查询文档中的内嵌的对象及数组 快速就地更新：查询优化器会分析查询表达式，并生成一个高效的查询计划 高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 安装msi提示错误代码2503、2502]]></title>
    <url>%2F2018%2F01%2F02%2Fnode-js-reinstall%2F</url>
    <content type="text"><![CDATA[之前尝试在win 10系统上搭建 Hugo 时，不小心把电脑上的所有环境变量 Path 都删掉了，重新添加找目录又费劲，所以直接重新下载了 node.js 和 Python，安装时又发现不断出现弹窗，显示: “The installer has encountered an unexpected error installing this package.this may indicate a problem with package.the error code is 2502.The installer has encountered an unexpected error installing this package.this may indicate a problem with package.the error code is 2503.” 应该是权限问题，Google找解决办法，都没解决，后来综合了两个解决方法，成功安装。 具体步骤： 永久提权1、按WIN+R，在运行框中输入“gpedit.msc” 确认；2、打开本地策略组编辑器后依次展开 ：“计算机配置”-》“管理模板”-》“windows组件”-》“windows installer”，并找到“始终以提升的权限进行安装”；3、双击该选项，设置为“已启用”，并应用；4、最后还要在【用户配置】中进行同样的操作； 临时安装1、鼠标移到桌面左下角-&gt;右键（或者直接： WIN+X键），命令提示符（管理员）；2、输入：msiexec /package +‘msi文件路径’（输入的时候注意半角字符且路径不能为中文名）例如：C:\Windows\system32&gt;msiexec /package G:\tool\node-v8.9.3-x64.msiC:\Windows\system32&gt;msiexec /package G:\software\python\python-3.4.3.msiC:\Windows\system32&gt;msiexec /package G:\software\python\python-2.7.10.msi 大功告成。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 学习笔记（四）]]></title>
    <url>%2F2017%2F11%2F14%2Fpython3-note40%2F</url>
    <content type="text"><![CDATA[python3 学习笔记（一） python3 学习笔记（二） python3 学习笔记（三） 文件在操作文件的整体过程与使用word编写一份简历的过程是很相似的： 打开文件，或者新建立一个文件 读/写数据 关闭文件 打开文件在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式) 示例如下：1f = open('test.txt', 'w') 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 关闭文件close( ) 示例如下： 12345# 新建一个文件，文件名为:test.txtf = open('test.txt', 'w')# 关闭这个文件f.close() 写数据(write)使用write()可以完成向文件写入数据 demo: 123f = open('test.txt', 'w')f.write('hello world, i am here!')f.close() 读数据(read)使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 demo: 12345678910111213f = open('test.txt', 'r')content = f.read(5)print(content)print("-"*30)content = f.read()print(content)f.close() 读数据（readlines）就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素 1234567891011121314#coding=utf-8f = open('test.txt', 'r')content = f.readlines()print(type(content))i=1for temp in content: print("%d:%s"%(i, temp)) i+=1f.close() 读数据（readline）123456789101112#coding=utf-8f = open('test.txt', 'r')content = f.readline()print("1:%s"%content)content = f.readline()print("2:%s"%content)f.close() 应用1——制作文件备份123456789101112131415161718192021222324252627#coding=utf-8oldFileName = input("请输入要拷贝的文件名字:")oldFile = open(oldFileName,'r')# 如果打开文件if oldFile: # 提取文件的后缀 fileFlagNum = oldFileName.rfind('.') if fileFlagNum &gt; 0: fileFlag = oldFileName[fileFlagNum:] # 组织新的文件名字 newFileName = oldFileName[:fileFlagNum] + '[复件]' + fileFlag # 创建新文件 newFile = open(newFileName, 'w') # 把旧文件中的数据，一行一行的进行复制到新文件中 for lineContent in oldFile.readlines(): newFile.write(lineContent) # 关闭文件 oldFile.close() newFile.close()]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 学习笔记（四）]]></title>
    <url>%2F2017%2F11%2F14%2Fpython3-note4%2F</url>
    <content type="text"><![CDATA[python3 学习笔记（一） python3 学习笔记（二） python3 学习笔记（三） 文件在操作文件的整体过程与使用word编写一份简历的过程是很相似的： 打开文件，或者新建立一个文件 读/写数据 关闭文件 打开文件在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式) 示例如下：1f = open('test.txt', 'w') 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 关闭文件close( ) 示例如下： 12345# 新建一个文件，文件名为:test.txtf = open('test.txt', 'w')# 关闭这个文件f.close() 写数据(write)使用write()可以完成向文件写入数据 demo: 123f = open('test.txt', 'w')f.write('hello world, i am here!')f.close() 读数据(read)使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 demo: 12345678910111213f = open('test.txt', 'r')content = f.read(5)print(content)print("-"*30)content = f.read()print(content)f.close() 读数据（readlines）就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素 1234567891011121314#coding=utf-8f = open('test.txt', 'r')content = f.readlines()print(type(content))i=1for temp in content: print("%d:%s"%(i, temp)) i+=1f.close() 读数据（readline）123456789101112#coding=utf-8f = open('test.txt', 'r')content = f.readline()print("1:%s"%content)content = f.readline()print("2:%s"%content)f.close() 应用1——制作文件备份123456789101112131415161718192021222324252627#coding=utf-8oldFileName = input("请输入要拷贝的文件名字:")oldFile = open(oldFileName,'r')# 如果打开文件if oldFile: # 提取文件的后缀 fileFlagNum = oldFileName.rfind('.') if fileFlagNum &gt; 0: fileFlag = oldFileName[fileFlagNum:] # 组织新的文件名字 newFileName = oldFileName[:fileFlagNum] + '[复件]' + fileFlag # 创建新文件 newFile = open(newFileName, 'w') # 把旧文件中的数据，一行一行的进行复制到新文件中 for lineContent in oldFile.readlines(): newFile.write(lineContent) # 关闭文件 oldFile.close() newFile.close()]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 学习笔记（三）]]></title>
    <url>%2F2017%2F11%2F14%2FPython3-note3%2F</url>
    <content type="text"><![CDATA[python3 学习笔记（一） python3 学习笔记（二） 函数如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数。 定义函数定义函数的格式如下：12def 函数名(): 代码 Demo:12345# 定义一个函数，能够完成打印信息的功能 def printInfo(): print '------------------------------------' print ' 人生苦短，我用Python' print '------------------------------------' 调用函数定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它 调用函数很简单的，通过 函数名() 即可完成调用12# 定义完函数后，函数是不会自动执行的，需要调用它才可以printInfo() 函数的文档说明1234567&gt;&gt;&gt; def test(a,b):... "用来完成对2个数求和"... print("%d"%(a+b))... &gt;&gt;&gt; &gt;&gt;&gt; test(11,22)33 如果执行，以下代码1&gt;&gt;&gt; help(test) 能够看到test函数的相关说明12345Help on function test in module __main__:test(a, b) 用来完成对2个数求和(END) 函数参数(一) 定义时小括号中的参数，用来接收参数用的，称为 “形参” 调用时小括号中的参数，用来传递给函数用的，称为 “实参” 定义带有参数的函数示例如下：123def add2num(a, b): c = a+b print c 调用带有参数的函数以调用上面的add2num(a, b)函数为例: 12345def add2num(a, b): c = a+b print cadd2num(11, 22) #调用带有参数的函数时，需要在小括号中，传递数据 调用函数时参数的顺序12345678910111213&gt;&gt;&gt; def test(a,b):... print(a,b)... &gt;&gt;&gt; test(1,2)1 2&gt;&gt;&gt; test(b=1,a=2)2 1&gt;&gt;&gt; &gt;&gt;&gt; test(b=1,2) File "&lt;stdin&gt;", line 1SyntaxError: positional argument follows keyword argument&gt;&gt;&gt; &gt;&gt;&gt; 函数参数(二)缺省参数调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：12345678def printinfo( name, age = 35 ): # 打印任何传入的字符串 print "Name: ", name print "Age ", age# 调用printinfo函数printinfo(name="miki" )printinfo( age=9,name="miki" ) 以上实例输出结果： Name: miki Age 35 Name: miki Age 9 注意：带有默认值的参数一定要位于参数列表的最后面。12345&gt;&gt;&gt; def printinfo(name, age=35, sex):... print name... File "&lt;stdin&gt;", line 1SyntaxError: non-default argument follows default argument 不定长参数有时可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。 基本语法如下：1234def functionname([formal_args,] *args, **kwargs): "函数_文档字符串" function_suite return [expression] 加了星号（*）的变量args会存放所有未命名的变量参数，args为元组；而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典。 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; def fun(a, b, *args, **kwargs):... """可变参数演示示例"""... print "a =", a... print "b =", b... print "args =", args... print "kwargs: "... for key, value in kwargs.items():... print key, "=", value...&gt;&gt;&gt; fun(1, 2, 3, 4, 5, m=6, n=7, p=8) # 注意传递的参数对应a = 1b = 2args = (3, 4, 5)kwargs: p = 8m = 6n = 7&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c = (3, 4, 5)&gt;&gt;&gt; d = &#123;"m":6, "n":7, "p":8&#125;&gt;&gt;&gt; fun(1, 2, *c, **d) # 注意元组与字典的传参方式a = 1b = 2args = (3, 4, 5)kwargs: p = 8m = 6n = 7&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fun(1, 2, c, d) # 注意不加星号与上面的区别a = 1b = 2args = ((3, 4, 5), &#123;'p': 8, 'm': 6, 'n': 7&#125;)kwargs:&gt;&gt;&gt;&gt;&gt;&gt; 引用传参可变类型与不可变类型的变量分别作为函数参数时，会有什么不同吗？Python有没有类似C语言中的指针传参呢？12345678910111213141516&gt;&gt;&gt; def selfAdd(a):... """自增"""... a += a...&gt;&gt;&gt; a_int = 1&gt;&gt;&gt; a_int1&gt;&gt;&gt; selfAdd(a_int)&gt;&gt;&gt; a_int1&gt;&gt;&gt; a_list = [1, 2]&gt;&gt;&gt; a_list[1, 2]&gt;&gt;&gt; selfAdd(a_list)&gt;&gt;&gt; a_list[1, 2, 1, 2] Python中函数参数是引用传递（注意不是值传递）。对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量。 函数返回值(一) 所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果 带有返回值的函数想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例:123def add2num(a, b): c = a+b return c 或者12def add2num(a, b): return a+b 保存函数的返回值如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存 保存函数的返回值示例如下:123456789#定义函数def add2num(a, b): return a+b#调用函数，顺便保存函数的返回值result = add2num(100,98)#因为result已经保存了add2num的返回值，所以接下来就可以使用了print result 结果: 198 函数返回值(二)在python中我们可不可以返回多个值？12345678910&gt;&gt;&gt; def divid(a, b):... shang = a//b... yushu = a%b ... return shang, yushu...&gt;&gt;&gt; sh, yu = divid(5, 2)&gt;&gt;&gt; sh5&gt;&gt;&gt; yu1 本质是利用了元组 4种函数的类型函数根据有没有参数，有没有返回值，可以相互组合，一共有4种,定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同： 无参数，无返回值 无参数，又反悔 有参数，无返回值 有参数，有返回值 无参数，无返回值的函数此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数12345678def printMenu(): print('--------------------------') print(' xx涮涮锅 点菜系统') print('') print(' 1. 羊肉涮涮锅') print(' 2. 牛肉涮涮锅') print(' 3. 猪肉涮涮锅') print('--------------------------') 无参数，有返回值的函数此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数 12345678910111213 # 获取温度 def getTemperature(): #这里是获取温度的一些处理过程 #为了简单起见，先模拟返回一个数据 return 24 temperature = getTemperature() print('当前的温度为:%d'%temperature)结果: 当前的温度为: 24 有参数，无返回值的函数此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数 有参数，有返回值的函数此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数 123456789101112131415# 计算1~num的累积和def calculateNum(num): result = 0 i = 1 while i&lt;=num: result = result + i i+=1 return resultresult = calculateNum(100)print('1~100的累积和为:%d'%result) 结果: 1~100的累积和为: 5050 函数的嵌套调用 一个函数里面又调用了另外一个函数，这就是所谓的函数嵌套调用 如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置 123456789101112131415def testB(): print('---- testB start----') print('这里是testB函数执行的代码...(省略)...') print('---- testB end----')def testA(): print('---- testA start----') testB() print('---- testA end----')testA() 结果： ---- testA start---- ---- testB start---- 这里是testB函数执行的代码...(省略)... ---- testB end---- ---- testA end---- 函数应用打印图形123456789101112131415# 打印一条横线def printOneLine(): print("-"*30)# 打印多条横线def printNumLine(num): i=0 # 因为printOneLine函数已经完成了打印横线的功能， # 只需要多次调用此函数即可 while i&lt;num: printOneLine() i+=1printNumLine(3) 数学计算12345678910111213141516# 求3个数的和def sum3Number(a,b,c): return a+b+c # return 的后面可以是数值，也可是一个表达式# 完成对3个数求平均值def average3Number(a,b,c): # 因为sum3Number函数已经完成了3个数的就和，所以只需调用即可 # 即把接收到的3个数，当做实参传递即可 sumResult = sum3Number(a,b,c) aveResult = sumResult/3.0 return aveResult# 调用函数，完成对3个数求平均值result = average3Number(11,2,55)print("average is %d"%result) 局部变量 局部变量，就是在函数内部定义的变量 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用 全局变量 在函数外定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧:强龙不压地头蛇 可变类型的全局变量123456789101112131415161718192021&gt;&gt;&gt; a = 1&gt;&gt;&gt; def f():... a += 1... print a...&gt;&gt;&gt; f()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in fUnboundLocalError: local variable 'a' referenced before assignment&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; li = [1,]&gt;&gt;&gt; def f2():... li.append(1)... print li...&gt;&gt;&gt; f2()[1, 1]&gt;&gt;&gt; li[1, 1] 小总结： 在函数中不使用global声明全局变量时不能修改全局变量的本质是不能修改全局变量的指向，即不能将全局变量指向新的数据。 对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。 对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量。 面向对象 面向过程：根据业务逻辑从上到下写代码。面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程。 类和对象面向对象编程的2个非常重要的概念：类和对象 对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类 类人以类聚 物以群分。 具有相似内部状态和运动规律的实体的集合(或统称为抽象)。 具有相同属性和行为事物的统称 类的构成类(Class) 由3个部分构成 类的名称:类名 类的属性:一组数据 类的方法:允许对进行操作的方法 (行为) 举例：1）人类设计,只关心3样东西: 事物名称(类名):人(Person)属性:身高(height)、年龄(age)方法(行为/功能):跑(run)、打架(fight) 2）狗类的设计类名:狗(Dog)属性:品种 、毛色、性别、名字、 腿儿的数量方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 类的抽象如何把日常生活中的事物抽象成程序中的类? 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 方法:一般名词都是类(名词提炼法) 坦克发射3颗炮弹轰掉了2架飞机坦克–》可以抽象成 类炮弹–》可以抽象成类飞机-》可以抽象成类 小明在公车上牵着一条叼着热狗的狗小明–》 人类公车–》 交通工具类热狗–》 食物类狗–》 狗类 定义类定义一个类，格式如下：12class 类名: 方法列表 demo：定义一个Car类12345678# 定义类class Car: # 方法 def getCarInfo(self): print('车轮子个数:%d, 颜色%s'%(self.wheelNum, self.color)) def move(self): print("车正在移动...") 对象某一个具体事物的存在,在现实世界中可以是看得见摸得着的。可以是直接使用的。 创建对象python中，可以根据已经定义的类去创建出一个个对象 创建对象的格式为:1对象名 = 类名() 创建对象demo:12345678910111213141516171819# 定义类class Car: # 移动 def move(self): print('车在奔跑...') # 鸣笛 def toot(self): print("车在鸣笛...嘟嘟..")# 创建一个对象，并用变量BMW来保存它的引用BMW = Car()BMW.color = '黑色'BMW.wheelNum = 4 #轮子数量BMW.move()BMW.toot()print(BMW.color)print(BMW.wheelNum) 总结： BMW = Car()，这样就产生了一个Car的实例对象，此时也可以通过实例对象BMW来访问属性或者方法 第一次使用BMW.color = ‘黑色’表示给BMW这个对象添加属性，如果后面再次出现BMW.color = xxx表示对属性进行修改 BMW是一个对象，它拥有属性（数据）和方法（函数） 当创建一个对象时，就是用一个模子，来制造一个实物 init()方法在上一小节的demo中，我们已经给BMW这个对象添加了2个属性，wheelNum（车的轮胎数量）以及color（车的颜色），试想如果再次创建一个对象的话，肯定也需要进行添加属性，显然这样做很费事，那么有没有办法能够在创建对象的时候，就顺便把车这个对象的属性给设置呢？ 答: __init__()方法 使用方式1234def 类名: #初始化函数，用来完成一些默认的设定 def __init__(): pass ###init()方法的调用123456789101112131415# 定义汽车类class Car: def __init__(self): self.wheelNum = 4 self.color = '蓝色' def move(self): print('车在跑，目标:夏威夷')# 创建对象BMW = Car()print('车的颜色为:%s'%BMW.color)print('车轮胎数量为:%d'%BMW.wheelNum) 总结: 当创建Car对象后，在没有调用init()方法的前提下，BMW就默认拥有了2个属性wheelNum和color，原因是init()方法是在创建对象后，就立刻被默认调用了 调用时传参既然在创建完对象后init()方法已经被默认的执行了，那么能否让对象在调用init()方法的时候传递一些参数呢？如果可以，那怎样传递呢？ 123456789101112131415# 定义汽车类class Car: def __init__(self, newWheelNum, newColor): self.wheelNum = newWheelNum self.color = newColor def move(self): print('车在跑，目标:夏威夷')# 创建对象BMW = Car(4, 'green')print('车的颜色为:%s'%BMW.color)print('车轮子数量为:%d'%BMW.wheelNum)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 学习笔记（二）]]></title>
    <url>%2F2017%2F11%2F08%2FPython3-note2%2F</url>
    <content type="text"><![CDATA[python3 学习笔记（一） 字符串双引号或者单引号中的数据，就是字符串。 字符串输出123456name = 'KyreneWang'position = 'Beijing'print('--------------------------------------------------')print("Name：%s"%name)print("position：%s"%position)print('--------------------------------------------------') 字符串输入123456#!/usr/bin/env python# coding:utf8userName = input('请输入用户名:')print("用户名为：%s"%userName)password = input('请输入密码:')print("密码为：%s"%password) 下标如果想取出部分字符，那么可以通过 下标 的方法（python中下标从 0 开始）。 切片切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片的语法：[起始:结束:步长] 选取的区间属于 左闭右开型，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。 12name = 'abcdef'print(name[0:3]) # 取 下标0~2 的字符，即abc 列表1namesList = ['xiaoWang','xiaoZhang','xiaoHua'] 比C语言的数组强大的地方在于列表中的元素可以是不同类型的1testList = [1, 'a'] 列表的循环遍历用 for 遍历123namesList = ['xiaoWang','xiaoZhang','xiaoHua']for name in namesList: print(name) 用 whlie 遍历123456namesList = ['xiaoWang','xiaoZhang','xiaoHua']length = len(namesList)i = 0while i&lt;length: print(namesList[i]) i+=1 列表的常见操作列表中存放的数据是可以进行修改的，比如”增”、”删”、”改”” 添加元素append 通过append可以向列表添加元素 1234567891011121314#定义变量A，默认有3个元素A = ['xiaoWang','xiaoZhang','xiaoHua']print("-----添加之前，列表A的数据-----")for tempName in A: print(tempName)#提示、并添加元素temp = input('请输入要添加的学生姓名:')A.append(temp)print("-----添加之后，列表A的数据-----")for tempName in A: print(tempName) extend 通过extend可以将另一个集合中的元素逐一添加到列表中 12345678&gt;&gt;&gt; a = [1, 2]&gt;&gt;&gt; b = [3, 4]&gt;&gt;&gt; a.append(b)&gt;&gt;&gt; a[1, 2, [3, 4]]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, [3, 4], 3, 4] insert insert(index, object) ：在指定位置index前插入元素object 1234&gt;&gt;&gt; a = [0, 1, 2]&gt;&gt;&gt; a.insert(1, 3)&gt;&gt;&gt; a[0, 3, 1, 2] 修改元素 修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改 12345678910111213#定义变量A，默认有3个元素A = ['xiaoWang','xiaoZhang','xiaoHua']print("-----修改之前，列表A的数据-----")for tempName in A: print(tempName)#修改元素A[1] = 'xiaoLu'print("-----修改之后，列表A的数据-----")for tempName in A: print(tempName) 结果: -----修改之前，列表A的数据----- xiaoWang xiaoZhang xiaoHua -----修改之后，列表A的数据----- xiaoWang xiaoLu xiaoHua 查找元素 所谓的查找，就是看看指定的元素是否存在 in, not inpython中查找的常用方法为： in（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false 1234567891011#待查找的列表nameList = ['xiaoWang','xiaoZhang','xiaoHua']#获取用户要查找的名字findName = input('请输入要查找的姓名:')#查找是否存在if findName in nameList: print('在字典中找到了相同的名字')else: print('没有找到') in的方法只要会用了，那么not in也是同样的用法，只不过not in判断的是不存在 index, count(index和count与字符串中的用法相同) 1234567891011&gt;&gt;&gt; a = ['a', 'b', 'c', 'a', 'b']&gt;&gt;&gt; a.index('a', 1, 3) # 注意是左闭右开区间Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 'a' is not in list&gt;&gt;&gt; a.index('a', 1, 4)3&gt;&gt;&gt; a.count('b')2&gt;&gt;&gt; a.count('d')0 删除元素类比现实生活中，如果某位同学调班了，那么就应该把这个条走后的学生的姓名删除掉；在开发中经常会用到删除这种功能。 列表元素的常用删除方法有： del：根据下标进行删除 1234567891011movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情']print('------删除之前------')for tempName in movieName: print(tempName)del movieName[2]print('------删除之后------')for tempName in movieName: print(tempName) pop：删除最后一个元素 1234567891011movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情']print('------删除之前------')for tempName in movieName: print(tempName)movieName.pop()print('------删除之后------')for tempName in movieName: print(tempName) remove：根据元素的值进行删除 1234567891011movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情']print('------删除之前------')for tempName in movieName: print(tempName)movieName.remove('指环王')print('------删除之后------')for tempName in movieName: print(tempName) 排序(sort, reverse)sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 reverse方法是将list逆置。 123456789101112&gt;&gt;&gt; a = [1, 4, 2, 3]&gt;&gt;&gt; a[1, 4, 2, 3]&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a[3, 2, 4, 1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4]&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; a[4, 3, 2, 1] 列表的嵌套类似while循环的嵌套，列表也是支持嵌套的 一个列表中的元素又是一个列表，那么这就是列表的嵌套123schoolNames = [['北京大学','清华大学'], ['南开大学','天津大学','天津师范大学'], ['山东大学','中国海洋大学']] 应用Demo：一个学校，有3个办公室，现在有8位老师等待工位的分配，编写程序，完成随机的分配12345678910111213141516171819202122232425#encoding=utf-8import random# 定义一个列表用来保存3个办公室offices = [[],[],[]]# 定义一个列表用来存储8位老师的名字names = ['A','B','C','D','E','F','G','H']i = 0for name in names: index = random.randint(0,2) offices[index].append(name)i = 1for tempNames in offices: print('办公室%d的人数为:%d'%(i,len(tempNames))) i+=1 for name in tempNames: print("%s"%name,end='') print("\n") print("-"*20) 元组Python的元组与列表类似，不同之处在于元组的元素不能修改或删除其中元素。元组使用小括号，列表使用方括号。 123&gt;&gt;&gt; aTuple = ('et',77,99.9)&gt;&gt;&gt; aTuple('et',77,99.9) 访问元祖123&gt;&gt;&gt; tuple = ('hello',100,3.14)&gt;&gt;&gt; tuple[0]'hello' 元组的内置函数count, indexindex和count与字符串和列表中的用法相同1234567891011&gt;&gt;&gt; a = ('a', 'b', 'c', 'a', 'b')&gt;&gt;&gt; a.index('a', 1, 3) # 注意是左闭右开区间Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: tuple.index(x): x not in tuple&gt;&gt;&gt; a.index('a', 1, 4)3&gt;&gt;&gt; a.count('b')2&gt;&gt;&gt; a.count('d')0 字典字典既能存储多个数据，还能在访问元素的很方便就能够定位到需要的那个元素。 定义变量info为字典类型：1info = &#123;'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'&#125; 说明： 字典和列表一样，也能够存储多个数据 列表中找某个元素时，是根据下标进行的 字典中找某个元素时，是根据’名字’（就是冒号:前面的那个值，例如上面代码中的’name’、’id’、’sex’） 字典的每个元素由2部分组成，键:值。例如 ‘name’:’班长’ ,’name’为键，’班长’为值 根据键访问值1234info = &#123;'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'&#125;print(info['name'])print(info['address']) 在不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值：1234567&gt;&gt;&gt; age = info.get('age')&gt;&gt;&gt; age #'age'键不存在，所以age为None&gt;&gt;&gt; type(age)&lt;type 'NoneType'&gt;&gt;&gt;&gt; age = info.get('age', 18) # 若info中不存在'age'这个键，就返回默认值18&gt;&gt;&gt; age18 字典的常见操作修改元素字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改1234567info = &#123;'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'&#125;newId = input('请输入新的学号')info['id'] = int(newId)print('修改之后的id为%d:'%info['id']) 添加元素如果在使用 变量名[‘键’] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素。123456789info = &#123;'name':'班长', 'sex':'f', 'address':'地球亚洲中国北京'&#125;# print('id为:%d'%info['id'])#程序会终端运行，因为访问了不存在的键newId = input('请输入新的学号')info['id'] = newIdprint('添加之后的id为:%d'%info['id']) 删除元素对字典进行删除操作，有一下几种： del删除指定的元素 1234567info = &#123;'name':'班长', 'sex':'f', 'address':'地球亚洲中国北京'&#125;print('删除前,%s'%info['name'])del info['name']print('删除后,%s'%info['name']) del删除整个字典 1234567 info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;print('删除前,%s'%info)del infoprint('删除后,%s'%info) clear清空整个字典 1234567info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;print('清空前,%s'%info)info.clear()print('清空后,%s'%info) 其他常见操作 len()测量字典中，键值对的个数 keys返回一个包含字典所有KEY的列表 values返回一个包含字典所有value的列表 items返回一个包含所有（键，值）元祖的列表 has_key如果key在字典中，返回True，否则返回False 遍历 通过for … in …:的语法结构，我们可以遍历字符串、列表、元组、字典等数据结构。（注意python语法的缩进） 字符串遍历12345&gt;&gt;&gt; a_str = "hello itcast"&gt;&gt;&gt; for char in a_str:... print(char,end=' ')...h e l l o i t c a s t 列表遍历12345&gt;&gt;&gt; a_list = [1, 2, 3, 4, 5]&gt;&gt;&gt; for num in a_list:... print(num,end=' ')...1 2 3 4 5 元组遍历1234&gt;&gt;&gt; a_turple = (1, 2, 3, 4, 5)&gt;&gt;&gt; for num in a_turple:... print(num,end=" ")1 2 3 4 5 公共运算符 运算符 Python表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ‘Hi!’ * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 +123456&gt;&gt;&gt; "hello " + "itcast"'hello itcast'&gt;&gt;&gt; [1, 2] + [3, 4][1, 2, 3, 4]&gt;&gt;&gt; ('a', 'b') + ('c', 'd')('a', 'b', 'c', 'd') *123456&gt;&gt;&gt; 'ab'*4'ababab'&gt;&gt;&gt; [1, 2]*4[1, 2, 1, 2, 1, 2, 1, 2]&gt;&gt;&gt; ('a', 'b')*4('a', 'b', 'a', 'b', 'a', 'b', 'a', 'b') in12345678&gt;&gt;&gt; 'itc' in 'hello itcast'True&gt;&gt;&gt; 3 in [1, 2]False&gt;&gt;&gt; 4 in (1, 2, 3, 4)True&gt;&gt;&gt; "name" in &#123;"name":"Delron", "age":24&#125;True python内置函数Python包含了以下内置函数 序号 方法 描述 1 cmp(item1, item2) 比较两个值 2 len(item) 计算容器中元素个数 3 max(item) 返回容器中元素最大值 4 min(item) 返回容器中元素最小值 5 del(item) 删除变量 cmp123456789101112131415161718&gt;&gt;&gt; cmp("hello", "itcast")-1&gt;&gt;&gt; cmp("itcast", "hello")1&gt;&gt;&gt; cmp("itcast", "itcast")0&gt;&gt;&gt; cmp([1, 2], [3, 4])-1&gt;&gt;&gt; cmp([1, 2], [1, 1])1&gt;&gt;&gt; cmp([1, 2], [1, 2, 3])-1&gt;&gt;&gt; cmp(&#123;"a":1&#125;, &#123;"b":1&#125;)-1&gt;&gt;&gt; cmp(&#123;"a":2&#125;, &#123;"a":1&#125;)1&gt;&gt;&gt; cmp(&#123;"a":2&#125;, &#123;"a":2, "b":1&#125;)-1 注意：cmp在比较字典数据时，先比较键，再比较值。 len12345678&gt;&gt;&gt; len("hello itcast")12&gt;&gt;&gt; len([1, 2, 3, 4])4&gt;&gt;&gt; len((3,4))2&gt;&gt;&gt; len(&#123;"a":1, "b":2&#125;)2 注意：len在操作字典数据时，返回的是键值对个数。 max12345678910&gt;&gt;&gt; max("hello itcast")'t'&gt;&gt;&gt; max([1,4,522,3,4])522&gt;&gt;&gt; max(&#123;"a":1, "b":2&#125;)'b'&gt;&gt;&gt; max(&#123;"a":10, "b":2&#125;)'b'&gt;&gt;&gt; max(&#123;"c":10, "b":2&#125;)'c' deldel有两种用法，一种是del加空格，另一种是del() 1234567891011121314151617&gt;&gt;&gt; a = 1&gt;&gt;&gt; a1&gt;&gt;&gt; del a&gt;&gt;&gt; aTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'a' is not defined&gt;&gt;&gt; a = ['a', 'b']&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a['b']&gt;&gt;&gt; del(a)&gt;&gt;&gt; aTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'a' is not defined 多维列表/元祖访问的示例123456789101112131415161718192021222324&gt;&gt;&gt; tuple1 = [(2,3),(4,5)]&gt;&gt;&gt; tuple1[0](2, 3)&gt;&gt;&gt; tuple1[0][0]2&gt;&gt;&gt; tuple1[0][2]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: tuple index out of range&gt;&gt;&gt; tuple1[0][1]3&gt;&gt;&gt; tuple1[2][2]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range&gt;&gt;&gt; tuple2 = tuple1+[(3)]&gt;&gt;&gt; tuple2[(2, 3), (4, 5), 3]&gt;&gt;&gt; tuple2[2]3&gt;&gt;&gt; tuple2[2][0]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'int' object is not subscriptable 引用-在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标示。1234567891011&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a) 13033816&gt;&gt;&gt; id(b) # 注意两个变量的id值相同13033816&gt;&gt;&gt; a = 2&gt;&gt;&gt; id(a) # 注意a的id值已经变了13033792&gt;&gt;&gt; id(b) # b的id值依旧13033816 12345678910111213&gt;&gt;&gt; a = [1, 2]&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)139935018544808&gt;&gt;&gt; id(b)139935018544808&gt;&gt;&gt; a.append(3)&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; id(a)139935018544808&gt;&gt;&gt; id(b) # 注意a与b始终指向同一个地址139935018544808 可变类型与不可变类型可变类型，值可以改变： 列表 list 字典 dict 不可变类型，值不可以改变： 数值类型 int, long, bool, float 字符串 str 元组 tuple]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 学习笔记（一）]]></title>
    <url>%2F2017%2F10%2F28%2FPython3-note%2F</url>
    <content type="text"><![CDATA[认识 Python Python的发音与拼写 [ˈpaɪθən] Python的意思是蟒蛇，源于作者喜欢的一部电视剧 (C呢？) Python的作者是Guido van Rossum（龟叔） Python是龟叔在1989年圣诞节期间，为了打发无聊的圣诞节而用C编写的一个编程语言 Python正式诞生于1991年 Python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在Java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（Python实现的，支持JIT即时编译） Python目前有两个版本，Python2和Python3，最新版分别为2.7.12和3.5.2，现阶段大部分公司用的是Python2 Python优缺点优点 简单————Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格。 易学————Python有极其简单的语法。 免费、开源————Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。 高层语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。 可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。 解释性————一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当运行程序的时候，连接/转载器软件把程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码，可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。 面向对象————Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。 可扩展性————如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把部分程序用C或C++编写，然后在Python程序中使用它们。 丰富的库————Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。 规范的代码————Python采用强制缩进的方式使得代码具有极佳的可读性。 缺点 运行速度，有速度要求的话，用C++改写关键部分吧。 国内市场较小（国内以python来做主要开发的，目前只有一些web2.0公司）。但时间推移，目前很多国内软件公司，尤其是游戏公司，也开始规模使用他。 中文资料匮乏（好的python中文资料屈指可数）。托社区的福，有几本优秀的教材已经被翻译了，但入门级教材多，高级内容还是只能看英语版。 构架选择太多（没有像C#这样的官方.net构架，也没有像ruby由于历史较短，构架开发的相对集中。Ruby on Rails 构架开发中小型web程序天下无敌）。不过这也从另一个侧面说明，python比较优秀，吸引的人才多，项目也多。 解释器&amp;脚本文件Python 是一个脚本语言，可以在 Python 解释器中直接写代码或者将代码写到一个文件里，然后执行这个文件（即脚本文件）。 1234567891011$ python3&gt;&gt;&gt; print("Hello World!")Hello World!exit() vim helloworld.py #按i进入插入模式#!/usr/bin/env python3 print("Hello World!") #输完文本按esc退出，并敲：wq$ chmod +x helloworld.py #给文件添加可执行权限$ ./helloworld.py 代码风格建议在 Python 中，空格很重要，使用空格将标识符区分开，行开始处的空格我们称之为缩进，如果缩进是错误的，Python 解释器会抛出错误。 所以建议遵守以下约定： 使用 4 个空格来缩进 永远不要混用空格和制表符 在函数之间空一行 在类之间空两行 字典，列表，元组以及参数列表中，在 , 后添加一个空格。对于字典，: 后面也添加一个空格 在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里侧不加空格：a = f(1, 2) + g(3, 4) 注释Python 的注释以 # 字符开始的，在 # 字符到行尾之间的所有东西都被程序忽略为注释，也就说对程序没有任何影响。快捷键为Ctrl+/。 多行注释是用三引号包含的。 变量和数据类型关键字和标识符Python3 的关键字，不能用于通常的标识符。关键字可以通过 Python3 解释器中得到： 123$ python3&gt;&gt;&gt; help（）help&gt; keywords 在 Python 中不需要为变量指定数据类型。所以可以直接写出 abc = 1 ，这样变量 abc 就是整数类型。如果写出 abc = 1.0 ，那么变量 abc 就是浮点类型。 Python 也能操作字符串，它们用单引号或双引号括起来，就像下面这样。 123$ python3&gt;&gt;&gt; "Hello World!"&gt;&gt;&gt; 'Hello World!' 从键盘读取输入通常情况下，Python 的代码中是不需要从键盘读取输入的。不过我们还是可以在 Python 中使用函数 input() 来做到这一点，input() 有一个用于打印在屏幕上的可选字符串参数，返回用户输入的字符串。 单行定义多个变量或赋值12345&gt;&gt;&gt; a , b = 45, 54&gt;&gt;&gt; a45&gt;&gt;&gt; b54 这个技巧用来交换两个数的值非常方便: 12345&gt;&gt;&gt; a, b = b , a&gt;&gt;&gt; a54&gt;&gt;&gt; b45 要明白这是怎么工作的，需要学习元组（tuple）这个数据类型。python3用逗号创建元组。在赋值语句的右边创建了一个元组，称这为元组封装（tuple packing），赋值语句的左边则做的是元组拆封 （tuple unpacking）。下面是另一个元组拆封的例子： 12345678&gt;&gt;&gt; data = ("mute", "China", "Python")&gt;&gt;&gt; name, country, language = data&gt;&gt;&gt; name'mute'&gt;&gt;&gt; country'China'&gt;&gt;&gt; language'Python' 运算符和表达式运算符运算符是一些符号，它告诉 Python 解释器去做一些数学或逻辑操作。只要有任意一个操作数是浮点数，结果就会是浮点数。 进行除法运算时若是除不尽，结果将会是小数，这很自然，如果要进行整除，使用 // 运算符，它将返回商的整数部分。 关系运算符 Operator Meaning &lt; Is less than &lt;= Is less than or equal to &gt; Is greater than &gt;= Is greater than or equal to == Is equal to != Is not equal to 举一些例子： 12345678&gt;&gt;&gt; 1 &lt; 2True&gt;&gt;&gt; 3 &gt; 34False&gt;&gt;&gt; 23 == 45False&gt;&gt;&gt; 34 != 323True 逻辑运算符对于逻辑 与，或，非，使用 and，or，not 这几个关键字。 逻辑运算符 and 和 or 也称作短路运算符：它们的参数从左向右解析，一旦结果可以确定就停止。例如，如果 A 和 C 为真而 B 为假，A and B and C 不会解析 C 。作用于一个普通的非逻辑值时，短路运算符的返回值通常是能够最先确定结果的那个操作数。 关系运算可以通过逻辑运算符 and 和 or 组合，比较的结果可以用 not 来取反意。逻辑运算符的优先级又低于关系运算符，在它们之中，not 具有最高的优先级，or 优先级最低，所以 A and not B or C 等于 (A and (notB)) or C。当然，括号也可以用于比较表达式。 举一些例子：12345678&gt;&gt;&gt; 5 and 44&gt;&gt;&gt; 0 and 40&gt;&gt;&gt; False or 3 or 03&gt;&gt;&gt; 2 &gt; 1 and not 3 &gt; 5 or 4True 简写运算符x op= expression 为简写运算的语法形式。其等价于 x = x op expression ，举例如下：12345678910&gt;&gt;&gt; a = 12&gt;&gt;&gt; a += 13&gt;&gt;&gt; a25&gt;&gt;&gt; a /= 3&gt;&gt;&gt; a8.333333333333334&gt;&gt;&gt; a += (26 * 32)&gt;&gt;&gt; a840.3333333333334 表达式123456789101112131415#!/usr/bin/env python3a = 9b = 12c = 3x = a - b / 3 + c * 2 - 1y = a - b / (3 + c) * (2 - 1)z = a - (b / (3 + c) * 2) - 1print("X = ", x)print("Y = ", y)print("Z = ", z)$ ./evaluationexp.pyX = 10Y = 7Z = 4 类型转换 类型转换函数 转换路径 float(string) 字符串 -&gt; 浮点值 int(string) 字符串 -&gt; 整数值 str(integer) 整数值 -&gt; 字符串 str(float) 浮点值 -&gt; 字符串 1234&gt;&gt;&gt; a = 8.126768&gt;&gt;&gt; str(a)'8.126768'总结 除了数值运算，关系和逻辑运算也是程序的重要组成部分。另外 Python 是强类型语言，所以必要的时候需要手动进行类型转换。 判断语句if-else1234if 条件: 满足条件时要做的事情else: 不满足条件时要做的事情 elif123456if xxx1: 事情1elif xxx2: 事情2elif xxx3: 事情3 Demo： 123456789101112score = 77if score&gt;=90 and score&lt;=100: print('本次考试，等级为A')elif score&gt;=80 and score&lt;90: print('本次考试，等级为B')elif score&gt;=70 and score&lt;80: print('本次考试，等级为C')elif score&gt;=60 and score&lt;70: print('本次考试，等级为D')elif score&gt;=0 and score&lt;60: print('本次考试，等级为E') if嵌套12345678910if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 ...(省略)... if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 ...(省略)... Demo： 1234567891011ticket = 1 # 用1代表有车票，0代表没有车票knife = 9 # 刀子的长度，单位为cmif ticket == 1: print("有车票，可以进站") if knife &lt; 10: print("通过安检") else: print("没有通过安检")else: print("没有车票，不能进站") 小应用-猜拳游戏1234567891011121314151617import randomplayer = input('请输入：剪刀(0) 石头(1) 布(2):')player = int(player)computer = random.randint(0,2)# 用来进行测试#print('player=%d,computer=%d',(player,computer))if ((player == 0) and (computer == 2)) or ((player ==1) and (computer == 0)) or ((player == 2) and (computer == 1)): print('获胜，哈哈，你太厉害了')elif player == computer: print('平局，要不再来一局')else: print('输了，不要走，洗洗手接着来，决战到天亮') 循环语句while12345while 条件: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... Demo: 12345i = 0while i&lt;5: print("当前是第%d次执行循环"%(i+1)) print("i=%d"%i) i+=1 while循环嵌套要求：打印如下图形： * * * * * * * * * * * * * * * 参考代码： 123456789i = 1while i&lt;=5: j = 1 while j&lt;=i: print("* ",end='') j+=1 print("\n") i+=1 99乘法表 12345678i = 1while i&lt;=9: j=1 while j&lt;=i: print("%d*%d=%-2d "%(j,i,i*j),end='') j+=1 print('\n') i+=1 for1234for 临时变量 in 列表或者字符串等: 循环满足条件时执行的代码else: 循环不满足条件时执行的代码]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《极简宇宙史》]]></title>
    <url>%2F2017%2F10%2F05%2F%E6%9E%81%E7%AE%80%E5%AE%87%E5%AE%99%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[读这本书时一直在随着作者的描述去想象，却仍然无法在脑海里描绘出宇宙之磅礴之诡谲之绮丽之深邃。唯有感叹宇宙之浩瀚，人类之渺小。我们看到的太阳，永远是8分20秒之前的太阳，永远不可能是它当下的样子，甚至不在我们看到它在的地方，因为它已经绕着银河系中心旋转的轨道上移动了117,300公里。 大概四十亿年前，我们年轻的行星与另一颗行星撞在一起，后者大概有火星那么大，这次撞击从地球上扯了一块物质下来，被带入太空。在随后的几亿年时间里，所有那次撞击产生的碎片聚到一起，形成了一个球体绕着地球运行。等这一切尘埃落定之时，就是月球的诞生之日。 如果这次撞击发生在今天，其剧烈程度足以将地球上的一切生命抹去。而当时，我们的地球上还是一片荒芜，没有生命。有趣的是，如果没有这次灾难性的碰撞，我们就不会有月亮照亮我们的夜晚，没有潮汐变化，而地球上可能也不会出现如我们现在所熟悉的生命形式。当那颗蓝色的地球跃过月平线，出现在你眼前时，你意识到这场宇宙级的灾难事件所带来的创生与破坏一样伟大。 如果人类能够以某种方式收获太阳在一秒钟内辐射出的所有能量，它就足以满足我们全世界五亿年的能量需求。 我们可以依据原子的大小将它们分类。它们中最小的一个被称为氢原子。第二小的被称为氦原子。这两种原子加在一起构成了已知宇宙的百分之九十八的物质。的确很多。但与以前比，这个比例现在已经变小了，大概一百三十八亿年前，这两种原子几乎构成了宇宙中所有的已知物质。今天我们可以看到的除了氢与氦之外的原子还包括氮原子、碳原子、氧原子或银原子等。 热核聚变，一个用较小的原子核产生较大的原子核的过程。热核聚变反应能够发生的一个必要条件是巨大的能量，太阳压倒一切的自身引力就是这种巨大能量的来源。 我们的行星体积太小，而且不够致密，因此自身引力不足以让其内核达到足以触发热核聚变反应的温度和压力。在定义上，这就是行星与恒星的主要差别。 当两颗原子核融合在一起变成一个更大的原子核时，它们的一部分质量消失了。聚合而成的新核比创造它的两颗旧核的总质量来得轻。 太阳的爆炸将发生在五十亿年后的某个星期四，前后误差各三天。 时不时地，因为碰撞或其他某种扰动，某个或某些脏雪球（属于海王星）会脱离它们原本安静而遥远的绕日轨道。当它们朝向太阳飞行时，会慢慢来到较暖的环境并在太阳辐射的照耀下融化并留下长长的尾巴，这条尾巴里是微小的冰块或石块，在黑暗的背景下被阳光照得闪闪发光。这就是我们称之为“彗星”的天体。 从冥王星被发现并被称为太阳系第九大行星到这个称号被剥夺、归于矮行星的七十六个地球年里，它们绕太阳一周都没走完，也就是这一切都发生在冥王星上的一年时间里。冥王星的大小只有月球的四分之一。 一个储存着几千亿亿亿个可能彗星的彗星库形成一个巨大的球状星云，看起来就像占据了太阳与其他恒星之间的所有空间。这个彗星库被称为“奥尔特云”。 比邻星属于那种被称为红矮星的家族。它比太阳小很多（只有太阳的大约七分之一大），色调偏红。这也是红矮星名字的来源。红矮星非常普遍，天空里大多数恒星都属于红矮星。因为比太阳小，它微小的内核里原子聚合的速度比太阳慢好多好多。对恒星来说，大小，的确至关重要：体积越大，寿命越短。 从月球发出的光需要大约一秒到达地球，然后再花一秒返回。太阳就更远了。光需要八分二十秒才能到达地球，对话变得有趣起来，因为一方要等超过十六分钟才能听到对方对自己问题的回答。但在宇宙中，太阳到地球的距离只能说是近邻。如果现在你从比邻星边上致电地球，电话铃声将在四年两个月后响起。 保持S2以这种速度旋转而不被甩出去，所需要的质量要超过四百万颗太阳。 如果你把太阳系，以及其中的行星、小行星和彗星看成我们在宇宙里的家庭，把比邻星当作我们的邻居，那么银河系就是我们在宇宙中的大城市，一个由三千亿颗恒星构成的繁华都市，而我们的太阳，只是其中的一颗。 即使在人类混乱的历史上最黑暗的日子里，也有些人勇敢地挑战宗教权威，坚信其他世界的存在。意大利天主教教士乔达诺·布鲁诺就是其中的一个，因为公开宣传这种异教思想，他在一六〇〇年的意大利罗马被活活烧死。他宣称“有无数太阳与无数的地球存在，这些地球围绕着各自的太阳旋转”。他因这些信念而痛苦地死去。 银河系属于一个由五十四个不同星系通过引力相互纠缠而构成的一个小小星系群。科学家把这个星系群命名为“本星系群”。它的区域覆盖了宽度大约八百四十万光年的球状区域。银河系是其中第二大的成员，大王是仙女座星系。 我们的望远镜已经探测到并且绘出了这道墙。这个尽头，这道光线无法透过的墙被称为“临界最后散射面”。 水星看起来很普通，只比我们的月亮大了一点点，是太阳系八大行星中最小的一个。它是岩石质地，表面满是陨石坑，相当长的时间内都不会消失。水星没有大气层，因此也就没有气候变化来抹平它不规则的形状和伤痕。总之，水星不会是一个可能被选作度假目的地的行星。它自转一周需要五十九个地球日，也就是说水星上的一个夜晚相当于地球上的一个月，紧接着是同样漫长的白昼。水星上的白昼与黑夜都同地狱一般残酷，白天的温度可以高达430°C，到了晚上，又低到-180°C。 引力原来是宇宙的构造被它所含的物体弯曲所引起的。将物质与宇宙的局部几何联系起来并用以解释引力本质的理论，被称为广义相对论。 光，别名电磁辐射，可被认为既是微粒（光子），又是波。光波的高度代表着我们所称的强度。 包围着我们的各种光线，从最低到最高能量依次是：无线电波、微波、红外线、可见光、紫外线、X光和伽玛射线。无线电波有着很长的波长，波峰之间距离可从一米到十万公里或更长，而伽玛射线，其波长短于一毫米的十亿分之一——但它们都是光线。 我们所探测到的最遥远星光在到达我们的望远镜的旅途上走了一百三十八亿年时间，出发于宇宙黑暗世纪，当宇宙开始变得透明之时。 发现宇宙膨胀的是美国天文学家埃德温·哈勃，他是在一九二九年发现的，因此描述远处的星系越走越远这一行为的定律被命名为哈勃定律。 引力永远是互相吸引的，它永远让物体掉落，但竞争产生了层次，某些物体不得不往上走，以腾出空间容纳比自己更重的物体。]]></content>
      <categories>
        <category>读书记</category>
      </categories>
      <tags>
        <tag>天文</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构与算法】排序专题]]></title>
    <url>%2F2017%2F10%2F02%2Falgorithm-sort%2F</url>
    <content type="text"><![CDATA[算法分析 时间复杂度-执行时间(比较和交换次数) 空间复杂度-所消耗的额外内存空间 使用小堆栈或表 使用链表或指针、数组索引来代表数据 排序数据的副本 对具有重键的数据(同一组数按不同键多次排序)进行排序时，需要考虑排序方法的稳定性，在非稳定性排序算法中需要稳定性时可考虑加入小索引。 稳定性：如果排序后文件中拥有相同键的项的相对位置不变，这种排序方式是稳定的。 常见的排序算法根据是否需要比较可以分为如下几类： Comparison Sorting Bubble Sort Selection Sort Insertion Sort Shell Sort Merge Sort Quck Sort Heap Sort Bucket Sort Counting Sort Radix Sort 从稳定性角度考虑可分为如下两类： 稳定 非稳定]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>DataStructure</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构与算法】二叉树专题]]></title>
    <url>%2F2017%2F09%2F30%2Falgorithm-binarytree%2F</url>
    <content type="text"><![CDATA[编程实现1234class TreeNode:def __init__(self, val): self.val = val self.left, self.right = None, None 树的遍历从二叉树的根节点出发，节点的遍历分为三个主要步骤：对当前节点进行操作（称为“访问”节点，或者根节点）、遍历左边子节点、遍历右边子节点。访问节点顺序的不同也就形成了不同的遍历方式。需要注意的是树的遍历通常使用递归的方法进行理解和实现，在访问元素时也需要使用递归的思想去理解。实际实现中对于前序和中序遍历可尝试使用递归实现。 按照访问根元素(当前元素)的前后顺序，遍历方式可划分为如下几种：深度优先：先访问子节点，再访问父节点，最后访问第二个子节点。 根据根节点相对于左右子节点的访问先后顺序又可细分为以下三种方式。前序(pre-order)：先根后左再右中序(in-order)：先左后根再右后序(post-order)：先左后右再根广度优先：先访问根节点，沿着树的宽度遍历子节点，直到所有节点均被访问为止。 如下图所示，遍历顺序在右侧框中，红色A为根节点。使用递归和整体的思想去分析遍历顺序较为清晰。 二叉树的广度优先遍历和树的前序/中序/后序遍历不太一样，前/中/后序遍历使用递归，也就是栈的思想对二叉树进行遍历，广度优先一般使用队列的思想对二叉树进行遍历。 如果已知中序遍历和前序遍历或者后序遍历，那么就可以完全恢复出原二叉树结构。其中最为关键的是前序遍历中第一个一定是根，而后序遍历最后一个一定是根，中序遍历在得知根节点后又可进一步递归得知左右子树的根节点。但是这种方法也是有适用范围的：元素不能重复！否则无法完成定位。 1234567891011121314151617181920212223242526class TreeNode: def __init__(self, val): self.val = val self.left, self.right = None, Noneclass Traversal(object): def __init__(self): self.traverse_path = list() def preorder(self, root): if root: self.traverse_path.append(root.val) self.preorder(root.left) self.preorder(root.right) def inorder(self,root): if root: self.inorder(root.left) self.traverse_path.append(root.val) self.inorder(root.right) def postorder(self,root): if root: self.postorder(root.left) self.postorder(root.right) self.traverse_path.append(root.val)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>DataStructure</tag>
        <tag>binarytree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构与算法】链表专题]]></title>
    <url>%2F2017%2F09%2F27%2Falgorithm-linkedlist%2F</url>
    <content type="text"><![CDATA[链表是线性表的一种。线性表是最基本、最简单、也是最常用的一种数据结构。线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。线性表有两种存储方式，一种是顺序存储结构，另一种是链式存储结构。我们常用的数组就是一种典型的顺序存储结构。 相反，链式存储结构就是两个相邻的元素在内存中可能不是相邻的，每一个元素都有一个指针域，指针域一般是存储着到下一个元素的指针。这种存储方式的优点是定点插入和定点删除的时间复杂度为 O(1)，不会浪费太多内存，添加元素的时候才会申请内存，删除元素会释放内存。缺点是访问的时间复杂度最坏为 O(n)。 顺序表的特性是随机读取，也就是访问一个元素的时间复杂度是O(1)，链式表的特性是插入和删除的时间复杂度为O(1)。 链表就是链式存储的线性表。根据指针域的不同，链表分为单向链表、双向链表、循环链表等等。 Python编程实现1234class ListNode: def __init__(self, val): self.val = val self.next = None 链表的基本操作反转链表单向链表链表的基本形式是：1 -&gt; 2 -&gt; 3 -&gt; null，反转需要变为 3 -&gt; 2 -&gt; 1 -&gt; null。这里要注意：访问某个节点 curt.next 时，要检验 curt 是否为 null。要把反转后的最后一个节点（即反转前的第一个节点）指向 null。 1234567891011121314class ListNode: def __init__(self, val): self.val = val self.next = None # in python next is a reversed word def reverse(self, head): prev = None while head: temp = head.next head.next = prev prev = head head = temp return prev 双向链表和单向链表的区别在于：双向链表的反转核心在于next和prev域的交换，还需要注意的是当前节点和上一个节点的递推。 12345678910111213class DListNode: def __init__(self, val): self.val = val self.prev = self.next = null def reverse(self, head): curt = None while head: curt = head head = curt.next curt.next = curt.prev curt.prev = head return curt 快慢指针快慢指针也是一个可以用于很多问题的技巧。所谓快慢指针中的快慢指的是指针向前移动的步长，每次移动的步长较大即为快，步长较小即为慢，常用的快慢指针一般是在单链表中让快指针每次向前移动2，慢指针则每次向前移动1。快慢两个指针都从链表头开始遍历，于是快指针到达链表末尾的时候慢指针刚好到达中间位置，于是可以得到中间元素的值。快慢指针在链表相关问题中主要有两个应用： 快速找出未知长度单链表的中间节点 设置两个指针 fast、slow 都指向单链表的头节点，其中fast的移动速度是slow的2倍，当*fast指向末尾节点的时候，slow正好就在中间了。 判断单链表是否有环 利用快慢指针的原理，同样设置两个指针 fast、slow 都指向单链表的头节点，其中 fast的移动速度是slow的2倍。如果 fast = NULL，说明该单链表 以 NULL结尾，不是循环链表；如果 fast = *slow，则快指针追上慢指针，说明该链表是循环链表。 12345678910111213141516171819class NodeCircle: def __init__(self, val): self.val = val self.next = None def has_circle(self, head): slow = head fast = head while (slow and fast): fast = fast.next slow = slow.next if fast: fast = fast.next if fast == slow: break if fast and slow and (fast == slow): return True else: return False Coding]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>DataStructure</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构与算法】字符串专题]]></title>
    <url>%2F2017%2F09%2F18%2Falgorithm-string%2F</url>
    <content type="text"><![CDATA[Python中字符串常用的方法1234567891011121314151617s1 = str()s2 = "mutemeteor" # 'mutemeteor's2len = len(s2)# last 3 charss2[-3:] # eors2[5:8] # etes3 = s2[:5] # mutems3 += 'eteor' # return 'mutemeteor'# list in python is same as ArrayList in Cs2list = list(s3)# string at index 4s2[4] # 'm'# find index at firsts2.index('u') # return 1, if not found, throw ValueErrors2.find('u') # return 1, if not found, return -1 Coding 处理字符串操作相关问题时，常见的做法是从字符串尾部开始编辑，从后往前逆向操作。这么做的原因是因为字符串的尾部往往有足够空间，可以直接修改而不用担心覆盖字符串前面的数据。 Implement strStrlintcode #13Problem Statement:Implement strStr().Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 -1。 1234567891011121314151617public class Solution &#123; public int strStr(String haystack, String needle) &#123; if (haystack == null &amp;&amp; needle == null) return 0; if (haystack == null) return -1; if (needle == null) return 0; for (int i = 0; i &lt; haystack.length() - needle.length() + 1; i++) &#123; int j = 0; for (; j &lt; needle.length(); j++) &#123; if (haystack.charAt(i+j) != needle.charAt(j)) break; &#125; if (j == needle.length()) return i; &#125; return -1; &#125;&#125; Two Strings Are AnagramsCompare StringsGroup AnagramsLongest Common SubstringRotate StringReverse Words in a StringValid PalindromeLongest Palindromic SubstringSpace ReplacementWildcard MatchingLength of Last WordsCount and Say]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>DataStructure</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程开发的技术基础 学习笔记]]></title>
    <url>%2F2017%2F09%2F16%2FSE-note%2F</url>
    <content type="text"><![CDATA[该学习笔记整理于南大软工教材《软件开发的技术基础-软件工程与计算（卷二）》。 最后更新时间：2017年9月27日 软件工程概论软件的核心是程序软件以程序代码为核心，由三个部分组成： 程序，机器指令的集合 文档，描述程序操作与使用的文档 数据，程序运行时需要使用的信息 软件工程定义（重点） 应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。 对 1 中各种方法的研究。 软件工程是一种工程活动具备所有工程学科共有的特性： 具有解决实际问题的动机 应用科学知识知指导工程活动 以成本效益比有效为基本条件 构建机器或事物 以服务人类为最终目的 软件工程的动机 软件工程要解决的实际问题可能是模糊的，而且通常都是模糊的，这就要求软件工程师在构建软件之前要花大力气澄清解决问题，明确项目目标。 软件工程知识域 软件技术知识域: 软件需求 软件设计 软件构造 软件测试 软件维护 软件管理知识域: 软件配置管理 软件工程管理 软件工程过程 软件工程工具与方法 软件质量 相关学科知识域 软件开发活动 需求开发 探索并明确描述现实世界信息 探索并定义问题 建立软件系统的解决方案 软件设计 软件体系结构设计，确定系统的高层结构 详细设计，将高层结构的部件设计为更为详细有效的模块与类，定义模块与类的功能以及它们的借口 人机交互设计 软件测构造 程序设计，以“数据结构+算法”的方式继续深化软件构建基本单位（模块或者类）的设计 编程，将程序设计方案映射为代码 调试 软件测试 技术上保证产品质量合格 需求上符合规格 软件交付与维护 安装与部署软件系统 培训用户使用软件并提供文档支持 项目启动项目管理基础团队的特征 团队成员要具备共同的目标 团队成员要共担责任 团队成员要技能互补 团队是小规模团体 团队内部要有一个明确的结构 团队结构 主程序员团队 民主团队 开放团队 团队建设 建立团队章程 持续成功 和谐沟通 避免团队杀手 软件质量IEEE1061-1992,1998的质量模型： 功能性 可靠性 易用性 效率 可维护性 可移植性 评审（peer review） planning overview preparation inspection meeting rework follow-up 质量度量(metric) 用数字量化的方式描述软件产品。 基于所有对象的代码行数测度可以建立平均代码行数/最大代码行数/最小代码行数等多个度量。 软件配置管理配置管理动机 配置管理的定义：用技术的和管理的指导和监督方法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与需求规格的一致性。 配置项 配置项的定义：置于软件配置管理之下的软件配置的各种相关项目，包括各种管理文档、评审记录与文档、软件文档、源代码及可执行代码、运行所需的系统软件和支持软件及有关数据等。 基线 基线的建立意味着一个里程碑，标志着产生基线制品活动的成功结束而后续协同开发活动的开始。 基线的定义：已经经过正式评审的规格说明或制品，可以作为进一步开发的基础，并且只有通过正式的变更控制过程才能变更。 配置管理活动 标识配置项 版本管理 变更控制 配置审计 状态报告 软件发布管理 需求开发阶段软件需求基础需求工程简介 需求工程 就是所有需求处理活动的总和，它收集信息、分析问题、整合观点、记录需求并验证其正确性，最终描述出软件被应用后与其环境互动形成的期望效应。 需求工程活动 需求开发 需求获取 需求分析 需求规格说明 需求验证 需求管理 需求获取 需求分析 需求规格说明 需求验证 需求管理 需求基础 需求 需求的层次性 结合层次性的需求开发 区分需求、问题域与规格说明 需求分类需求谱系软件需求的分类 需求分析方法需求分析基础6.1.1 需求分析的原因6.1.2 需求分析模型 结构化分析6.2.1 结构化分析方法6.2.2 数据流图6.2.3 实体关系图 面向对象分析6.3.1 面向对象分析方法6.3.2 用例6.3.3 用例图6.3.4 用例描述6.3.5 概念类图（领域模型）6.3.6 交互图（顺序图）6.3.7 状态图 使用需求分析方法细化和明确需求6.4.1 细化和明确需求内容6.4.2 建立系统级需求 需求文档化与验证文档化的原因需求文档基础7.2.1 需求文档的交流对象7.2.2 用例文档7.2.3 软件需求规格说明文档 需求文档化要点7.3.1 技术文档写作要点7.3.2 需求书写要点7.3.3 软件需求规格说明文档书写要点 评审软件需求规格说明文档7.4.1 需求验证与确认7.4.2 评审需求的注意事项 以需求为基础开发系统测试用例7.5.1 开发测试用例套件7.5.2 开发测试用例 度量需求将需求制品纳入配置管理 软件设计软件设计基础软件设计思想的发展 1985： “software”一词出现。当时为面向语句编程，所有数据都是全局的。 20世纪60年代中后期到70年代中期：语句层次 → 函数层次，主要进行“函数”和“过程”的设计。 20世纪中期后期开始到90年代：函数 → 模块，开始进行高质量的软件设计。 20世纪90年代之后：”大规模软件设计”年代 2000年年初至今：以重视体系结构/设计建模、重构等为代表的最佳设计实践方式被广泛应用。 软件设计的核心思想分解（decomposition）和 抽象（abstraction） 理解软件设计8.3.1 设计与软件设计8.3.2 工程设计与艺术设计8.3.3 理性主义和经验主义8.3.4 软件设计的演化性8.3.5 软件设计的决策性8.3.6 软件设计的约束满足和多样性 软件设计的分层软件设计过程的主要活动软件设计的方法和模型8.6.1 软件设计的方法8.6.2 软件设计的模型 软件设计描述8.7.1 设计视图和设计图8.7.2 设计视角和设计关注8.7.3 需求和涉众8.7.4 设计理由8.7.5 设计描述的模板 8.7.6 软件设计文档书写要点软件体系结构基础理解软件体系结构定义软件体系结构 = {部件，连接件，配置} 部件分为 原始 和 复合 两种类型。原始类型常用的软件实现机制： 模块 层 文件 数据库 进程 物理单元 连接件同样分为 原始 和 复合 两种类型。原始类型常用的软件实现机制： 隐式（程序调用、共享变量、消息、管道、事件、远程过程调用、网络协议、数据库访问协议） 显示（适配器、委托、中介） 配置将部件和连接件整合起来，构成系统整体结构的一种专门机制。用 体系结构描述语言 表达配置。 体系结构风格初步主程序/子程序主程序是系统的控制器，负责调度子程序的执行。各个子程序又是一个局部控制器，负责调度其子子程序执行。 基于声明-使用（程序调用）关系建立连接件。 主要实现机制：模块实现。 优点： 流程清晰，易于理解。 强控制性。（更能控制程序的正确性。） 缺点： 程序调用是一种强耦合的连接方式，非常依赖交互方的接口规格，这会使系统难以修改和复用。 程序调用的连接方式限制了各个部件之间的数据交互，可能会使不同部件使用隐含的共享数据交流产生不必要的公共耦合，进而破坏它的“正确性”控制能力。 应用： 主要用于能够将系统功能依层次分解为多个顺序执行步骤的系统。 面向对象式面向对象式风格将系统组织为多个独立的对象，每个对象封装其内部数据，并基于数据对外提供服务。不同对象之间通过协作机制共同完成系统任务。 基于方法调用机制建立连接件。每个对象都是一个自治单位。 主要实现机制：模块实现。 优点： 内部实现的可修改性。 易开发、易理解、易复用的结构组织。 缺点： 接口的耦合性。 标识的耦合性。 副作用。更难实现程序的“正确性”。 应用： 适用于能够基于数据信息分解和组织的软件系统，其能够标识和保护相关的数据信息；能够将数据信息和相关操作联系起来，进行封装。 分层根据不同的抽象层次，将系统组织为层次式结构。每个层次被建立为一个部件，不同部件之间通常用程序调用方式进行连接。 基于方法调用机制建立连接件。 优点： 设计机制清晰，易于理解。 支持并行开发。 更好的复用性和可修改性。 缺点： 交互协议难以修改。 性能损失。 难以确定层次数量和粒度。 应用： 主要功能是能在不同抽象层次上进行任务分解的复杂处理；能够建立不同抽象层次之间稳定的交互协议；能够容许稍许的延迟。 MVC模型-视图-控制（Model-View-Control，MVC）。 优点： 易开发性。 视图和控制的可修改性。 适宜于网络系统开发的特征。 缺点： 复杂性。 模型修改困难。 应用：主要用于网络系统的开发。如Web网页。 软件体系结构设计与构建体系结构设计过程分析关键需求和项目约束 关键需求： 概要功能需求 非概要功能需求（质量、性质、约束、接口） 项目约束：开发技术、环境、团队，项目预算、进度、风险，市场大小等等。 选择体系结构风格不同的风格有不同的特点，选择依据是风格的特点是否能与关键需求和项目约束相兼容。如，需要基于Web开发，更偏向Web应用的MVC风格就是选择之一；系统对实时性要求不高，对修改性和灵活性要求比较高，分层风格（展示层、逻辑层、数据层）可能就更合适。 选择了体系结构风格，可以用UML包图来描述。 软件体系结构逻辑设计 依据概要功能需求与体系结构风格建立初始设计 使用非功能性需求与项目约束评价和改进进行初始设计 软件体系结构实现 开发包（构件）设计 运行时的进程 物理部署 完善软件体系结构设计在完成软件体系结构设计的实现方案之后，往往还需要对其进行完善和细化。例如添加辅助构件以完成系统的特殊功能。 定义构件接口在完成软件体系结构设计之后，要定义构件之间的接口，这是进行软件体系结构设计文档化和交流的必要手段。 体系结构的原型构建包的创建包是用于将系统组织成层次结构的机制，可以根据构件设计来创建项目的包。 重要文件的创建包含类源文件，接口源文件，数据文件，项目配置文件，构建配置文件等。 定义构件之间的接口在包和文件定义之后，着力开始定义构件之间的接口。 关键需求的实现端到端实现需求。 体系结构集成与测试集成的策略 大爆炸集成 增量式集成 自顶向下式 自底向上式 三明治式 持续集成 桩、驱动与集成测试用例桩是在软件测试中用来替换某些模块的。桩一般和所替代的模块有相同的接口，并且模拟地实现了模块的行为。 桩模仿的是下层模块，用来测试上层；而驱动则模仿的是上层模块，来测试下层。 软件体系结构设计文档描述体系结构评审 人机交互设计人机交互设计的目标人机交互设计的人类因素精神模型差异性人机交互设计的计算机因素可视化设计常见界面类型人机交互设计的交互性导航反馈一些人机交互设计原则人机交互设计过程基本过程示例 详细设计的基础详细设计概述详细设计出发点详细设计的上下文结构化设计结构化设计的思想结构化设计的过程面向对象设计面向对象设计的思想面向对象设计的过程通过职责建立静态模型通过协作建立动态模型为类间协作开发集成测试用例详细设计文档描述详细设计的评审 详细设计中的模块化与信息隐藏模块化与信息隐藏思想13.1.1 设计质量13.1.2 模块化与信息隐藏思想的动机13.1.3 模块化与信息隐藏思想的发展 模块化13.2.1 分解与模块化13.2.2 结构化设计中的耦合13.2.3 结构化设计中的内聚13.2.4 回顾：MSCS系统设计中的模块化思想 信息隐藏13.3.1 抽象与信息隐藏13.3.2 信息与隐藏13.3.3 模块说明 13.3.4 回顾：MSCS系统设计中的信息思想详细设计中面向对象方法下的模块化面向对象中的模块14.1.1 类14.1.2 类之间的联系 访问耦合14.2.1 访问耦合的分析14.2.2 降低访问耦合的方法 继承耦合14.3.1 继承耦合的分析14.3.2 降低继承耦合的方法 内聚14.4.1 面向对象中的内聚14.4.2 提高内聚的方法 耦合与内聚的度量14.5.1 耦合的度量14.5.2 内聚的度量 详细设计中面向对象方法下的信息隐藏封装类的职责15.1.1 类的职责15.1.2 封装——分离接口与实现15.1.3 封装实现细节 为变更而设计15.2.1 封装变更/开闭原则15.2.2 多态15.2.3 依赖倒置原则 15.2.4 总结详细设计的设计模式设计模式基础可修改性及其基本实现机制策略模式16.3.1 典型问题16.3.2 设计分析16.3.3 解决方案16.3.4 模式实例 抽象工厂模式16.4.1 典型问题16.4.2 设计分析16.4.3 解决方案16.4.4 模式实例 单件模式16.5.1 典型问题16.5.2 设计分析16.5.3 解决方案16.5.4 模式实例 迭代器模式16.6.1 典型问题16.6.2 设计分析16.6.3 解决方案 16.6.4 模式实例软件构造、测试、交付与维护软件构造概述17.1.1 软件构造的定义17.1.2 软件构造是设计的延续 软件构造活动17.2.1 详细设计17.2.2 编程17.2.3 测试17.2.4 调试17.2.5 代码评审17.2.6 集成与构建17.2.7 构造管理 软件构造实践方法17.3.1 重构17.3.2 测试驱动开发17.3.3 结对编程 代码设计设计易读的代码18.1.1 格式18.1.2 命名18.1.3 注释 设计易维护的代码18.2.1 小型任务18.2.2 复杂决策18.2.3 数据使用18.2.4 明确依赖关系 设计可靠的代码18.3.1 契约式设计18.3.2 防御式编程 使用模型辅助设计复杂代码18.4.1 决策表18.4.2 伪代码18.4.3 程序流程图 为代码开发单元测试用例18.5.1 为方法开发测试用例18.5.2 使用Mock Object测试类方法18.5.3 为类开发测试用例 代码复杂度度量问题代码 软件测试引言19.1.1 验证与确认19.1.2 软件测试的目标19.1.3 测试用例19.1.4 桩与驱动19.1.5 缺陷、错误与失败 测试层次19.2.1 测试层次的划分19.2.2 单元测试19.2.3 集成测试19.2.4 系统测试 测试技术19.3.1 测试用例的选择19.3.2 随机测试19.3.3 基于规格的技术——黑盒测试方法19.3.4 基于代码的技术——白盒测试方法19.3.5 特定测试技术 测试活动测试度量 软件交付安装与部署20.1.1 安装20.1.2 部署 培训与文档支持20.2.1 培训20.2.2 文档支持 项目评价20.3.1 项目评价的原因20.3.2 项目评价的内容20.3.3 项目评价的方法 20.3.4 注意事项软件维护与演化软件维护21.1.1 软件可修改性与软件维护21.1.2 软件维护的类型21.1.3 软件维护的高代价性21.1.4 开发可维护的软件21.1.5 软件维护过程与活动 软件演化21.2.1 演化与维护21.2.2 软件演化定律21.2.3 软件演化生命周期模型与演化活动 软件维护与演化的常见技术21.3.1 遗留软件21.3.2 逆向工程 21.3.3 再工程软件过程模型与职业基础软件开发过程模型软件开发的典型阶段22.1.1 软件需求工程22.1.2 软件设计22.1.3 软件构造22.1.4 软件测试22.1.5 软件交付22.1.6 软件维护 软件生命周期模型软件过程模型（重点）软件生命周期模型知识界定了软件开发的不同阶段和阶段之间的顺序关系，软件过程模型则进一步详细说明各个阶段的任务、活动、对象及组织、控制过程。 构建-修复模型构建-修复模型最早也是最自然产生的软件开发模型。缺陷很明显，甚至不能算一个软件过程模型。 瀑布模型 20世纪70年代 自上而下、相互衔接的次序，按照“从一个阶段到另一个阶段的有序序列转换”的方式来组织开发活动。 允许活动出现反复和迭代。 局限性： 对文档的过高期望。 对开发活动的线性顺序假设。 客户、用户参与不够。 里程碑粒度过粗。 增量迭代模型 20世纪80年代 需求驱动 优点： 适用性强。 并行开发可以帮助缩短软件产品的开发时间。 渐进交付可以加强用户反馈，降低开发风险。 缺点： 各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具有开放式的体系结构。 需要一个完备、清晰的项目前景和范围进行并行开发规划，但不定性太多，很难在项目开始就确定前景和范围。 适用于比较成熟稳定的领域。 演化模型 需求驱动 优点： 迭代式开发，适用性强。 并行开发可以帮助缩短软件产品的开发时间。 渐进交付可以加强用户反馈，降低开发风险。 缺点： 无法在项目早期阶段确定项目范围。 容易让后续迭代蜕变为构建-修复方式。 主要用于需求变更比较频繁或不确定性比较多的领域。 原型模型螺旋模型Rational统一过程敏捷过程]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 学习笔记（三）]]></title>
    <url>%2F2017%2F09%2F10%2Fjava-note3%2F</url>
    <content type="text"><![CDATA[面向对象有三大特性：封装、继承、多态。 Java 封装封装封装是指，一种将抽象性函式接口的实例细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制，通过该类提供的方法来实现对隐藏信息的操作和访问。 那这样的好处是什么呢？ 只能通过规定的方法访问数据。 隐藏类的实例细节，方便修改和实现。 我们在开汽车的时候，只用去关注如何开车，我们并不在意车子是如何实现的，这就是封装。 如何去实现类的封装呢？ 修改属性的可见性，在属性的前面添加修饰符(private 后面会讲) 对每个值属性提供对外的公共方法访问，如创建 getter/setter（取值和赋值） 方法，用于对私有属性的访问 在 getter/setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定。 包有时候在封装的时候会遇到这样的问题，就是我们的类名可能是重复的。为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 包的作用 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。我们在以前就学习过了如何定义一个包，我们使用package关键字，加上我们的包名。 定义包语法：12package 包名//注意：必须放在源程序的第一行，包名可用"."号隔开 例如：123//我们在定义文件夹的时候利用"/"来区分层次//包中我们用"."来分层package com.test.Java 不仅是我们这样利用包名来区分类，系统也是这样做的。 访问修饰符private: 本类 默认：本类，同包 protected：本类，同包，子类 public：本类，同包，子类，其他 this关键字this关键字代表当前对象。使用this.属性操作当前对象的属性，this.方法调用当前对象的方法。 当我们封装对象属性的时候，经常会使用this关键字。 内部类可以将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类。 内部类的主要作用如下： 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 内部类的方法可以直接访问外部类的所有数据，包括私有的数据 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类允许继承多个非接口类型 注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。所以内部类的成员变量/方法名可以和外部类的相同。 Java 继承继承的定义继承可以看成是类与类之间的衍生关系。比如狗类是动物类，牧羊犬类又是狗类。于是我们可以说狗类继承了动物类，而牧羊犬类就继承了狗类。于是狗类就是动物类的子类（或派生类），动物类就是狗类的父类（或基类）。 class 子类 extends 父类 例如我们定义了一个 Animal 类，我们在创建一个 Dog 类，我们需要它继承 Animal 类 123class Dog extends Animal &#123; ...&#125; 为什么需要继承？ 如果有两个类相似，那么它们会有许多重复的代码，导致后果就是代码量大且臃肿，后期的维护性不高。通过继承就可以解决这个问题，将两段代码中相同的部分提取出来组成一个父类，实现代码的复用。 继承的特点： 子类拥有父类除private以外的所有属性和方法 子类可以拥有自己的属性和方法 子类可以重写实现父类的方法 Java 中的继承是单继承，一个类只有一个父类 注： Java 实现多继承的一个办法是 implements（实现）接口 方法的重写虽然子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，我们就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法。 当然在方法重写时我们需要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致。 继承的初始化顺序继承的初始化顺序是先初始化父类再初始化子类。 注：final关键字可以修饰类、方法、属性和变量 final 修饰类，则该类不允许被继承，为最终类 final 修饰方法，则该方法不允许被覆盖（重写） final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一） final 修饰变量，则该变量的值只能赋一次值，即变为常量 super关键字在子类内部使用，代表父类对象。 访问父类的属性 super.属性名 访问父类的方法 super.bark() 子类构造方法需要调用父类的构造方法时，在子类的构造方法体里最前面的位置：super() Java 多态多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象。 向上转型多态的实现条件Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。 只有满足上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 多态的实现方法Java中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现。 重写抽象类和抽象方法Java提供了一个叫做抽象方法的机制，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下： abstract void f(); //f()方法时抽象方法 而包含抽象方法的类叫做抽象类，抽象类在定义类时，前面会加abstract关键字。 那我们什么时候会用到抽象类呢？ 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现。 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 所以由上可知，抽象类是限制规定子类必须实现某些方法，但不关注实现细节。 那抽象类如何用代码实现呢，它的规则如下： 用 abstract 修饰符定义抽象类 用 abstract 修饰符定义抽象方法，只用声明，不需要实现 包含抽象方法的类就是抽象类 抽象类中可以包含普通的方法，也可以没有抽象方法 抽象类的对象不能直接创建，我们通常是定义引用变量指向子类对象。 接口实现abstract 关键字允许人们在类中创建一个或多个没有任何定义的方法，而 interface 使抽象的概念更向前迈进了一步，它会产生一个完全抽象类，根本没有提供任何方法体。 接口的声明语法格式如下： 1234修饰符 interface 接口名称 [extends 其他的类名] &#123; // 声明变量 // 抽象方法&#125; 如声明一个 Animal 接口： 1234567interface Animal &#123; //int x; //编译错误,x需要初始化，因为是 static final 类型 int y = 5; public void eat(); public void travel();&#125; 注意： 接口不能用于实例化对象 接口中所有的方法是抽象方法 接口成员是 static final 类型 接口支持多继承 多继承实现方式： 1234567修饰符 interface A extends 接口1，接口2&#123;&#125;修饰符 class A implements 接口1，接口2&#123;&#125; 实现上面的接口： 123456789101112131415public class Cat implements Animal&#123; public void eat()&#123; System.out.println("Cat eats"); &#125; public void travel()&#123; System.out.println("Cat travels"); &#125; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.eat(); cat.travel(); &#125;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 学习笔记（二）]]></title>
    <url>%2F2017%2F09%2F10%2Fjava-note2%2F</url>
    <content type="text"><![CDATA[Java 数组数组的定义和初始化三步曲：声明 → 分配空间（new关键字） → 初始化 声明 数据类型[ ] 数组名; //或者: 数据类型 数组名[ ]; 例如：12345int ages[]; //存放年龄的数组，类型为整型char symbol[]; //存放符号的数组，类型为字符型String [] name; //存放名称的数组，类型为字符串型 分配空间 1数组名 = new 数据类型 [ 数组长度 ]; 初始化 123int [] ages = &#123;12,18,9,33,45,60&#125;; //声明并初始化了一个整型数组，它有6个元素char [] symbol = new char[10] //声明并分配了一个长度为10的char型数组 一维数组一维数组是由元素组成单纯的线性结构的数组，简单来理解就是一串元素。 注意： 数组下标从 0 开始。所以数组的下标范围是0 至 数组长度-1。 数组不能越界访问，否则会报错。 二维数组二维数组可以看成是一间有座位的教室，每一个座位都有一个行和一个列的属性，一排的座位相当于一个一维数组，所以我们可以将二维数组简单的理解为是一种“特殊”的一维数组，它的每个数组空间中保存的是一个一维数组。 二维数组也需要声明和分配空间。 语法： 123456789101112131415数据类型 [][] 数组名 = new 数据类型[行的个数][列的个数];//或者数据类型 [][] 数组名;数组名 = new 数据类型[行的个数][列的个数];//也可以数据类型 [][] 数组名 = &#123;&#123;第一行值1,第一行值2,...&#125;&#123;第二行值1,第二行值2,...&#125;...&#125;//二维数组的赋值和访问，跟一维数组类似，可以通过下标来逐个赋值和访问，注意索引从 0 开始数组名[行的索引][列的索引] = 值; Java 方法方法的定义与语法规则Java中的方法，可以将其看成一个功能的集合，它们是为了解决特定问题的代码组合。比如司机会开车，老师会教书一样，不同的方法可以实现不同的功能。 方法的定义语法： 访问修饰符 返回值类型 方法名(参数列表){ 方法体 } 在上面的语法说明中： 访问修饰符：代表方法允许被访问的权限范围， 可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用，其他几种修饰符的使用我们会在后面章节中详细讲解。 返回值类型：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void (代表无类型)；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。 方法名：是方法的名字，必须使用合法的标识符。 参数列表：是传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 根据方法是否带参、是否带返回值，可将方法分为四类： 无参无返回值方法 无参带返回值方法 带参无返回值方法 带参带返回值方法 例如一下代码的calcSum方法用来计算两门课程的成绩总分： 123456789101112131415161718192021public class PrintScore &#123; public static void main(String[] args) &#123; // 创建对象，对象名为a PrintScore a = new PrintScore(); int rSum; //设置一个int型变量，用来接收方法的返回值 // 调用方法，传入两门课程的成绩 rSum = a.calcSum(78,99); System.out.println("总分："+ rSum); &#125; //功能：计算两门课程考试成绩的总分并输出总分 //定义一个包含两个参数的方法，用来传入两门课程的成绩 public int calcSum(int a, int b)&#123; int sum= a + b; return sum; &#125;&#125; 如上所示：方法名为calcSum，它的修饰符是public，它有两个参数int a和int b，在方法调用的时候必须传入这两个参数。它有一个int 型的返回值，所以在方法里，有一条语句return sum;用来返回sum的值，其中sum类型也为int 型。而在方法调用的时候，我们用一个int 型变量rSum来接收这个返回值。方法calcSum实现了将两门课程的总成绩算出并返回。 注意： 方法体放在一对大括号中，实现特定的操作 方法名主要在调用这个方法时使用，需要注意命名的规范，一般采用第一个单词首字母小写，其它单词首字母大写的形式 调用方法的语法是对象名.方法名 参数与参数列表可以通过在方法中加入参数列表接收外部传入的数据信息，参数可以是任意的基本类型数据或引用类型数据。123456789101112131415161718192021222324252627public class PrintScore &#123; public static void main(String[] args) &#123; // 创建对象，对象名为a PrintScore a = new PrintScore(); double rAve; //用来存放返回的平均成绩 //两课的成绩，是实际的参数 int sub1 = 78; int sub2 = 99; // 调用方法，传入两门课程的成绩 rAve = a.calcAve(sub1,sub2); System.out.println("平均分："+rAve); &#125; // 功能：计算两门课程考试成绩的平均分并输出平均分 // 定义一个包含两个参数的方法，用来传入两门课程的成绩 // 两个参数 a 和 b 为形参，只在方法内有效 public double calcAve(int a, int b)&#123; double ave = (a + b) / 2; return ave; &#125;&#125; 方法重载在Java中通过在类中写多个方法，这类方法的方法名相同，方法的参数列表不同（参数的个数和参数类型的不同）来实现方法的重载。所谓方法重载就是：在一个类中，有一系列的方法具有方法名相同，但参数列表不同，这类方法的实现就是方法重载。 在进行方法重载的时候需要遵循以下的规则： 在使用方法重载的时候，必须通过方法中不同的参数列表来实现方法的重载。如：方法的参数个数不同或者方法的参数类型不同。 不能通过访问权限，返回值类型和抛出的异常来实现重载。 重载的方法中允许抛出不同的异常。 可以有不同的返回值类型，只要方法的参数列表不同即可。 可以有不同的访问修饰符。 返回值方法是一个实现了条件输入和结果输出的过程，往往需要对方法的结果进行进一步的处理，这时候就需要方法返回值了。 注意： 如果方法的返回类型为 void ，则方法中不能使用 return 返回值。 方法的返回值最多只能有一个，不能返回多个值。 方法返回值的类型必须兼容，也就是说如果返回值类型为 int ，则不能返回 String 型值。 调用带返回值的方法时，由于方法执行后会返回一个结果，因此在调用带返回值方法时一般都会接收其返回值并进行处理。 Java 类与对象什么是面向对象面向对象，从字面意思来看就是我们人面对着一个对象。其实就是指我们从这个对象的整体出发去看它，它由哪些部件组成，它可以做到哪些事情。 比如我们想要买一部手机，我们想要内存大一点的，最新款的，CPU 运算快一点的，能实现发短信和打电话功能的手机。那么这部手机是不是对象呢？它不是。当我们买了一部 iPhone 6 后，它满足我们上面的所有信息。于是我们拿在手上的这部 iphone 6 就是我们的对象。于是我们知道，对象一定是一个具体的、确定的物体。 而这部手机它的样式，颜色，大小，产地，编号等等，便是这部手机的“属性”，这部手机可以打电话、发短信，便是它的“行为”。 面向对象的思想，体现的是人所关注对象的信息聚集在了一个具体的物体上。人们就是通过对象的属性和行为来了解对象。 类类是封装对象的属性和行为的载体，反过来说具有相同属性和行为的一类实体被称为类。类就是对象的抽象(或者模板)，对象就是类的具体（或者实例）。比如手机是一个抽象的概念，它代表着类。而一部 iphone 6 便是手机具象化处理的实体，也就是一个对象。 类的定义： 类是相同或相似对象的一种抽象，是对象的一个模板，它描述一类对象的行为和状态。 类是具有相同属性和方法（行为）的对象的集合 定义一个类，主要有三个步骤： 定义类名，用于区分不同的类。如下代码中 public class 后面跟的就是类名。class是我们声明类的关键字，类名后面跟上大括号，大括号里面就是我们类的一些信息。public我们会在后面详细讲解，大家先记着就行了。 编写类的属性。对象有什么，我们通过属性来表示。属性的定义我们是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性。 编写类的方法。方法也是写在大括号里面。我们可以定义一个方法或多个方法，当然也可以不定义方法。 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为static类型。 构造方法每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。 在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 构造方法的名称与类名相同，且没有返回值。它的语法格式如下： //与类同名，可以指定参数，没有返回值 public 构造方法名(){ //初始化代码 } 下面是一个构造方法的例子：12345678910public class People&#123; //无参构造方法 public People()&#123; &#125; //有一个参数的构造方法 public People(int age)&#123; &#125;&#125; 如果我们在定义类的时候没有写构造方法，系统会默认给我们生成一个无参构造方法，不过这个构造方法什么也不会做。 当有指定的构造方法时，系统都不会再为我们添加无参构造方法了。 构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。 对象创建对象的语法如下： 类名 对象名 = new 类名(); 比如对People这个类，我想实例化LiLei这个人。LiLei 的数据类型便是 People 这个类型。（类可以看成使我们自己定义的数据类型） People LiLei = new People(); 定义类的时候是不会为类开辟内存空间的，但是一旦创建了对象，系统就会在内存中为对象开辟一块空间，用来存放对象的属性值和方法。 1234567891011public class NewObject &#123; public static void main(String[] args) &#123; People LiLei = new People(); //创建一个People对象LiLei LiLei.height =170; LiLei.age = 20; LiLei.sex = 1; LiLei.printBaseMes(); &#125;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 学习笔记（一）]]></title>
    <url>%2F2017%2F09%2F10%2Fjava-note%2F</url>
    <content type="text"><![CDATA[HelloWorld 认识Java利用文本文件编辑 Java 程序开发一个Java程序，主要有三步。 第一步，使用文本文件去编写Java的源代码文件，Java的源代码文件以.java结尾，源代码文件默认是不能被机器执行的。 第二步，要使用编译器（也就是javac命令），对源代码文件进行编译的操作。把它编译成字节码文件，字节码文件是以.class结尾。它与平台无关，也就是说无论是windows还是linux，字节码文件都是这样的一个文件，这跟系统没有关系。实际上Java的跨平台就是因为字节码文件的存在。 第三步，就是解释器。针对不同的平台，根据相应的解释器，去解释运行字节码文件（这里使用java命令），最终我们可以看到程序运行出的结果。 具体实现： 输入javac helloworld.java,对源文件进行编译 桌面上多出了一个helloworld.class的文件 接着我们继续输入java helloworld（java 命令不能跟上文件的后缀名）, 对HelloWorld.class字节码文件利用解释器去执行它，即会打印结果。 ※ 实验注：类名和文件名必须相同！ Java代码详解 public是类修饰，表示公有，class是关键字类 ，HelloWorld是类名，类名一定要与 Java 文件名一致； 内部是一个main方法，是一个程序执行入口方法，方法上的public也是修饰，表示公有，static是静态修饰关键字，是类的一部分，不是对象的一部分，void是方法返回值，标识返回空，Java 必须用对象去调用方法，所以程序的入口方法是静态的； main是方法名，特殊方法，表示执行入口，括号里的String args[] 是方法参数，这里是指字符串数组，用来初始化程序； 方法里System.out.println是一个输出语句，输出括号里的内容。 Java 基本语法Java 程序的构成一个Java程序可以认为是一系列 对象 的集合，而这些 对象 通过调用彼此的方法来协同工作。 对象(object)：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类(class)：类是一个模板，它描述一类对象的行为和状态。 方法(method)：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。有些类似于C语言中的 函数 。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 Java 标识符Java 语言中，类、变量、常量、方法都需要名字，我们统统称之为 Java 标识符. 标识符是用来给类、对象、方法、变量、接口和自定义数据类型命名的。 关于 Java 标识符，有几点需要注意的： Java 标识符由数字，字母A-Z或者a-z和下划线_，美元符号$组成。 所有的标识符都应该以字母A-Z或者a-z,美元符$、或者下划线_开始，首位不能是数字。 关键字不能用作标识符。 在 Java 中是区分大小写的。 注：在 Java 中，还有一些约定俗成的命名规则： 类和接口名。每个字的首字母大写，含有大小写。例如，MyClass，HelloWorld，Time 等。 方法名。首字符小写，其余的首字母大写，含大小写。尽量少用下划线。例如，myName，setTime 等。这种命名方法叫做驼峰式命名。 常量名。基本数据类型的常量名使用全部大写字母，字与字之间用下划线分隔。对象常量可大小混写。例如，SIZE_NAME。 变量名。可大小写混写，首字符小写，字间分隔符用字的首字母大写。不用下划线，少用美元符号。给变量命名是尽量做到见名知意。 命名过程中尽量做到见名知意，方便后期查看和修改代码，也方便其他人员的阅读。 变量和常量变量变量代表程序的状态。程序通过改变变量的值来改变整个程序的状态。为了方便地引用变量的值，在程序中需要为变量设定一个名称，这就是变量名。 由于Java语言是一种强类型的语言，所以变量在使用以前必须首先声明，在程序中声明变量的语法格式如下： 数据类型 变量名称； 在 Java 中，变量需要先声明(declare)才能使用。在声明中，说明变量的类型，赋予变量以特别名字，以便在后面的程序中调用它。可以在程序中的任意位置声明变量。 Java中主要有如下几种类型的变量： 局部变量 类变量（静态变量） 成员变量（非静态变量） 常量常量代表程序运行过程中不能改变的值。我们也可以把它们理解为特殊的变量，只是它们在程序的运行过程中是不允许改变的。常量的值是不能被修改的。 常量的语法格式和变量类似，只需要在变量的语法格式前面添加关键字final即可。在Java编码规范中，要求常量名必须大写。 常量的语法格式如下： final 数据类型 常量名称 = 值； final 数据类型 常量名称1 = 值1， 常量名称2 = 值2，……常量名称n = 值n； final 用于声明属性（常量），方法和类，分别表示属性一旦被分配内存空间就必须初始化, 它的含义是“这是无法改变的”或者“终态的”。 注释一般在 Java 里有三种注释： 行注释//：只注释一行 段注释/…/：注释若干行 文档注释/**…*/：注释若干行，并写入 javadoc文档 Java 运算符2.1算术运算符 加，减，乘，除，取余，自增，自减。 位运算符 逻辑运算符 赋值运算符 关系运算符 条件运算符条件运算符?:是唯一的一个三目运算符。 语法形式：布尔表达式？表达式1 : 表达式2 运算过程：如果布尔表达式的值为true ，则返回 表达式1 的值，否则返回 表达式2 的值。 Java 控制语句条件控制语句if 语句 if 语句 123if(条件)&#123; 条件成立时执行的代码&#125; if - else 语句 123456if(条件)&#123; 代码块1&#125;else&#123; 代码块2&#125; if - else if - else 语句 12345678910if(条件1)&#123; 代码块1&#125;else if(条件2)&#123; 代码块2&#125;...else &#123; 代码块n&#125; switch语句1234567891011switch(表达式)&#123; case 值1: 代码块1 break; case 值2: 代码块2 break; ... default: 默认执行的代码块&#125; 当 switch 后表达式的值和 case 语句后的值相同时，从该位置开始向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。 循环控制语句while和do-while语句 while语法 123while(条件)&#123; 代码块&#125; do-while 123do&#123; 代码块&#125;while(条件); for语句123for(循环变量初始化; 循环条件; 循环变量变化)&#123; 循环操作&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Psychological Clinic]]></title>
    <url>%2F2017%2F08%2F10%2FPsychological-Clinic%2F</url>
    <content type="text"><![CDATA[This is a little detective story written in the writing practice course. 1“Dear Miss, what can I do for you?”“Oh…… I have heard that you are specialized in helping people solve problems, you are a qualified psychiatrist……”“Dare not guarantee to cure all mental problems. Yet the certificates on the wall behind me are all real.”“So I came to you.”“Your problem is?”“About love. ‘Women are born for love.’ What do you think of this idea?”“‘Life is dear, love is dearer. ’ This is especially true for women.”“Follow love and proceed without hesitation is not wrong, right?”“It can always be forgiven when a woman makes any mistake chasing love.”“Love ends up in marriage, doesn’t it?”“Generally speaking, yes.”“But they’re not the same……”“Love is romantic, marriage is realistic.”“But romance shouldn’t be hindered by reality, is it?”“If a man loves one, yet he gives up because of parents’ oppositions or for the sake of money, it will be a great pity.” 2“Do you have anything to say to me?”“I…… Must I say something?”“Psychological problems must be resolved or the consequences of accumulation are serious. That’s our rule here. If you don’t say anything at all, how can we help you?”“Well……I heard that your learning is profound and immense, I want to discuss……some philosophical problems.”“If there is anything in the world that can be described as profound knowledge, it must be philosophy.”“Actually, what I want to talk about is not philosophy, it’s a philosopher. How much do you know about Freud?”“His research is too numerous to mention.”“Oedipus complex……”“Really it’s not philosophy.”“What do you think of it?”“I do not quote any of his theories, just my views. I think it’s normal, even so the Oedipus complex can be said to be an animal instinct. The Encyclopedia of animals has introduced a duck. The male duck always looks for his spouse modeling after his mother.”“Is this a common phenomenon?”“Yes, men often have this affection.”“But shouldn’t parents be treated equally?””“A boy loves his mother more than he loves his father. It’s not unusual even after he grows up.”“Extreme, isn’t it?”“If you are suffering from certain stimuli, you will be more strongly defended.”“If the reaction has its cause, one cannot be too radical in matters like this?”“Motherhood is more glorious than anything, even human nature and reason. anyone harmful to the mother is the enemy of the son.” 3“You look very sad, madam.”“Yes. I have a lot of questions that I can’t figure out.”“For example?”“What others think of me……”“Dante said, ‘go your own way and let others talk.’”“I’m not so easy. But other people seem to think so, and they think that what they say doesn’t hurt anyone else, so they are irresponsible to……”“The world does have a lot of prejudices. For example, they think the stepmother is an old witch who enjoys abusing the children of ex-wife and also prefers to murder her husband. If a young lady marries an old man, it’s only for money.”“In fact, there are many possibilities and helplessness.”“If no one makes allowance for you, just be considerate of yourself.”“Comfort myself?”“Not only on the psychological level, but also into action, for example, try to fight for something.”“But I hate being predicted. They must be as complacent as seers: ‘look, she is just what we said. This is the human nature.’ Why not the different background, but the same way?”“All roads lead to Rome? It happens a lot. Don’t be afraid. Nobody knows the inside story. Isn’t it wonderful that there’s one thing only you know in the world? Think about what you really want.” 4“You don’t look very well. Relax. Don’t be nervous.”“I’ve come to talk to you about the choice.”“Em?”“Family and love, which do you think is more important?”“Different people have different views.”“People always say ‘the hate of the wife being abducted’ and ‘the revenge of the father being killed’, which seems to be the most intolerable. But they also say, ‘brothers are like hands while wives are like clothes.’ I do not know which one is right.”“Chinese people, if they have a theory, there must be an opposite one, it really causes some annoying headaches.”“What should I do……”“I can’t give a specific suggestion, just a personal opinion. The ancient Chinese values faithfulness, and on the account of the low status of women, love is so deep, even hard to speak out, so it produces the second kind of argument. But we are civilized westerners, right?” 5“How’s the investigation going?”“The famous Mr. Fog, got rich based on his ex-wife’s fortune and then was widowed by accident. Two years ago, he married a woman who was the younger brother’s girlfriend. If he dies before he changes his will next week, we can get four incomes at the same time. Your peers call you ‘scholar’, that really makes sense.”“Remember, knowledge is always useful.”]]></content>
      <categories>
        <category>子不语</category>
      </categories>
      <tags>
        <tag>Story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 学习笔记]]></title>
    <url>%2F2017%2F08%2F07%2FLinux%2F</url>
    <content type="text"><![CDATA[linux终端终端的概念通常我们在使用 Linux 时，并不是直接与系统打交道，而是通过一个叫做 Shell 的中间程序来完成的，在图形界面下为了实现让我们在一个窗口中完成用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序（Terminal），下面是几个比较常见的终端模拟器： gnome-terminal，kconsole，xterm，rxvt，kvt，nxterm 和 eterm 。 Shell通常在图形界面中对实际体验带来差异的不是上述的不同发行版的各种终端模拟器，而是这个 Shell（壳）。有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的软件（命令解析器），类似于 DOS 下的 command（命令行）和后来的 cmd.exe 。普通意义上的 Shell 就是可以接受用户输入命令的程序。它之所以被称作 Shell 是因为它隐藏了操作系统底层的细节。同样的 UNIX/Linux 下的图形用户界面 GNOME 和 KDE，有时也被叫做“虚拟 shell”或“图形 shell”。 UNIX/Linux 操作系统下的 Shell 既是用户交互的界面，也是控制系统的脚本语言。当然这一点也有别于 Windows 下的命令行，虽然该命令行也提供了很简单的控制语句。在 Windows 操作系统下，有些用户从来都不会直接使用 Shell，然而在 UNIX 系列操作系统下，Shell 仍然是控制系统启动、X11 启动和很多其它实用工具的脚本解释程序。 在 UNIX/Linux 中比较流行的常见的 Shell 有 bash、zsh、ksh、csh 等等，Ubuntu 终端默认使用的是 bash，默认的桌面环境是 GNOME 或者 Unity。 命令行操作[Tab]使用Tab键来进行命令补全，Tab键一般是在字母Q旁边，这个技巧给你带来的最大的好处就是当你忘记某个命令的全称时可以只输入它的开头的一部分，然后按下Tab键就可以得到提示或者帮助完成，当然不止补全命令，补全目录、补全命令参数都是没问题的。 [Ctrl+c]用Ctrl+c键来强行终止当前程序（且并不会使终端退出）。 其他一些常用快捷键: 按键 作用 Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl+z 将当前程序放到后台运行，恢复到前台为命令fg Ctrl+a 将光标移至输入行头，相当于Home键 Ctrl+e 将光标移至输入行末，相当于End键 Alt+Backspace 向前删除一个单词 Shift+PgUp 将终端显示向上滚动 Shift+PgDn 将终端显示向下滚动 历史输入命令很简单，使用键盘上的方向上键↑，恢复之前输入过的命令，一试便知。 通配符通配符是一种特殊语句，主要有星号（*）和问号（?），用来对字符串进行模糊匹配（比如文件名、参数名）。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正字符。 终端里面输入的通配符是由 Shell 处理的，不是由所涉及的命令语句处理的，它只会出现在命令的“参数值”里（它不能出现在命令名称里， 命令不记得，那就用Tab补全）。当 Shell 在“参数值”中遇到了通配符时，Shell 会将其当作路径或文件名在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换（路径扩展）；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符实际上就是一种 Shell 实现的路径扩展功能。在通配符被处理后， Shell 会先完成该命令的重组，然后继续处理重组后的命令，直至执行该命令。 Shell 常用通配符： 字符 含义 * 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [!list] 匹配 除list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] {string1,string2,...} 匹配 string1 或 string2 (或更多)其一字符串 {c1..c2} 匹配 c1-c2 中全部字符 如{1..10}]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 学习笔记]]></title>
    <url>%2F2017%2F07%2F23%2Fvim%2F</url>
    <content type="text"><![CDATA[从vi演生出来的Vim具有多种模式，这种独特的设计容易使初学者产生混淆。几乎所有的编辑器都会有插入和执行命令两种模式，并且大多数的编辑器使用了与Vim截然不同的方式：命令目录（鼠标或者键盘驱动），组合键（通常通过control键（CTRL）和alt键（ALT）组成）或者鼠标输入。Vim和vi一样，仅仅通过键盘来在这些模式之中切换。这就使得Vim可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。 Vim 的6种模式普通模式(Normal mode)在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。 Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。 插入模式(Insert mode)在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。 在插入模式中，可以按ESC键回到普通模式。 可视模式(Visual mode)这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。 选择模式(Select mode)这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。 命令行模式(Command line mode)在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。 Ex模式(Ex mode)这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。 这其中我们常用到就是普通模式、插入模式和命令行模式。 三种常用模式的切换vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。 进入vim使用vim命令进入vim界面vim后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名。 打开终端，输入以下命令： $ vim practice_1.txt 直接使用vim也可以打开vim编辑器，但是不会打开任何文件： $ vim 进入命令行模式后输入:e 文件路径 同样可以打开相应文件。 游标移动在进入vim后，按下i键进入插入模式。按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。 按键 说明 h 左 l 右 j 下 k 上 w 移动到下一个单词 e 移动到上一个单词 进入插入模式在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入 命令 说明 i 在当前光标处进行编辑 I 在行首插入 A 在行末插入 a 在光标后插入编辑 o 在当前行后插入一个新行 O 在当前行前插入一个新行 cw 替换从光标所在位置后到一个单词结尾的字符 保存文档从普通模式输入:进入命令行模式，输入w回车，保存文档。输入:w 文件名可以将文档另存为其他文件名或存到其它路径下。 退出vim命令行模式下退出vim从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑。 命令 说明 :q! 强制退出，不保存 :q 退出 :wq! 强制保存并退出 :w &lt;文件路径&gt; 另存为 :saveas 文件路径 另存为 :x 保存并退出 :wq 保存并退出 普通模式下退出vim普通模式下输入Shift+zz即可保存退出vim。 删除文本进入普通模式，使用下列命令可以进行文本快速删除： 命令 说明 x 删除游标所在的字符 X 删除游标所在前一个字符 Delete 同x dd 删除整行 dw 删除一个单词（不适用中文） d$或D 删除至行尾 d^ 删除至行首 dG 删除到文档结尾处 d1G 删至文档首部 除此之外，还可以在命令之前加上数字，表示一次删除多行，如：2dd表示一次删除2行。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 学习笔记之进阶篇]]></title>
    <url>%2F2017%2F07%2F20%2FMySQL2%2F</url>
    <content type="text"><![CDATA[进阶篇 - MySQL 服务安装及命令使用进阶篇 - MySQL 操作详解进阶篇 - MySQL 常用查询进阶篇 - MySQL 语言结构进阶篇 - MySQL 数据类型进阶篇 - MySQL 函数和操作符进阶篇 - SQL 语句语法详解进阶篇 - MySQL 触发器进阶篇 - MySQL 视图进阶篇 - MySQL 存储过程和函数进阶篇 - MySQL 数据库管理]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 学习笔记之基础篇]]></title>
    <url>%2F2017%2F03%2F31%2FMySQL1%2F</url>
    <content type="text"><![CDATA[基础篇 - SQL 介绍数据库和 SQL 概念数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，它的产生距今已有六十多年。 结构化查询语言(Structured Query Language)简称 SQL，是上世纪 70 年代由 IBM 公司开发，用于对数据库进行操作的语言。SQL 是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名。 MySQLMySQL 是一个 DBMS（数据库管理系统），由瑞典 MySQLAB 公司开发，目前属于 Oracle 公司，MySQL 是最流行的关系型数据库管理系统。MySQL 是一个 DBMS（数据库管理系统），由瑞典 MySQLAB 公司开发，目前属于 Oracle 公司，MySQL 是最流行的关系型数据库管理系统 尝试 MySQL打开 MySQL# 启动 MySQL 服务 sudo service mysql start #使用 root 用户登录，密码为空 mysql -u root 查看数据库使用命令 show databases;，查看有哪些数据库。 连接数据库选择连接其中一个数据库，语句格式为 use &lt;数据库名&gt;，这里可以不用加分号。 查看表使用命令 show tables; 查看数据库中有哪些表（不要漏掉“;”）。 基础篇 - 创建数据库并插入数据新建数据库语句格式为 CREATE DATABASE &lt;数据库名字&gt;;,在大多数系统中，SQL 语句都是不区分大小写的，但是出于严谨，而且便于区分保留字（保留字(reserved word)：指在高级语言中已经定义过的字，使用者不能再将这些字作为变量名或过程名使用。）和变量名，我们把保留字大写，把变量和数据小写。 连接数据库首先要连接数据库，使用语句 use &lt;数据库名字&gt;。 数据表数据表（table）简称表，它是数据库最重要的组成部分之一。数据库只是一个框架，表才是实质内容。而一个数据库中一般会有多张表，这些各自独立的表通过建立关系被联接起来，才成为可以交叉查阅、一目了然的数据库。 新建数据表在数据库中新建一张表的语句格式为： CREATE TABLE 表的名字 ( 列名a 数据类型(数据长度), 列名b 数据类型(数据长度)， 列名c 数据类型(数据长度) ); 数据类型 数据类型 大小(字节) 用途 格式 INT 4 整数 FLOAT 4 单精度浮点数 DOUBLE 8 双精度浮点数 ENUM 单选,比如性别 ENUM(‘a’,’b’,’c’) SET 多选 SET(‘1’,’2’,’3’) DATE 3 日期 YYYY-MM-DD TIME 3 时间点或持续时间 HH:MM:SS YEAR 1 年份值 YYYY CHAR 0~255 定长字符串 VARCHAR 0~255 变长字符串 TEXT 0~65535 长文本数据 整数除了 INT 外，还有 TINYINT、SMALLINT、MEDIUMINT、BIGINT。 整数除了 INT 外，还有 TINYINT、SMALLINT、MEDIUMINT、BIGINT。CHAR 和 VARCHAR 的区别: CHAR 的长度是固定的，而 VARCHAR 的长度是可以变化的，比如，存储字符串 “abc”，对于 CHAR(10)，表示存储的字符将占 10 个字节(包括 7 个空字符)，而同样的 VARCHAR(12) 则只占用4个字节的长度，增加一个额外字节来存储字符串本身的长度，12 只是最大值，当你存储的字符小于 12 时，按实际长度存储。 插入数据使用语句 SELECT * FROM 表的名字; 查看表中的内容，刚建的表内是空的，通过 INSERT 语句向表中插入数据，语句格式为： INSERT INTO 表的名字(列名a,列名b,列名c) VALUES(值1,值2,值3); 例如像表employee内加入内容： INSERT INTO employee(id,name,phone) VALUES(01,&apos;Tom&apos;,110110110); INSERT INTO employee VALUES(02,&apos;Jack&apos;,119119119); INSERT INTO employee(id,name) VALUES(03,&apos;Rose&apos;); 有的数据需要用单引号括起来，比如 Tom、Jack、Rose 的名字，这是由于它们的数据类型是 CHAR 型。此外 VARCHAR,TEXT,DATE,TIME,ENUM 等类型的数据也需要单引号修饰，而 INT,FLOAT,DOUBLE 等则不需要。 基础篇 - SQL 的约束约束分类约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。在MySQL中，通常有这几种约束： 约束类型： 主键 默认值 唯一 外键 非空 关键字： PRIMARY KEY DEFAULT UNIQUE FOREIGN KEY NOT NULL 主键 (PRIMARY KEY)是用于约束表中的一行，作为这一行的唯一标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。主键不能有重复且不能为空。还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识。 默认值约束 (DEFAULT) 规定，当有 DEFAULT 约束的列，插入数据为空时，将使用默认值。DEFAULT 约束只会在使用 INSERT 语句时体现出来，INSERT语句中，如果被 DEFAULT 约束的位置没有值，那么这个位置将会被 DEFAULT 的值填充。 基础篇 - SELECT 语句详解基础篇 - 数据库及表的修改和删除基础篇 - 其他基本操作]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《思维导图使用手册》]]></title>
    <url>%2F2017%2F02%2F03%2F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[寒假在家读了几本书，整理了几个导图。 东尼·博赞的这本书可以说是思维导图制作的入门书，内容不多，算上做图的时间，大概读了两个小时左右。总得来说讲的还是比较浅，加读《如何阅读一本书》效果可能会更好。 《思维导图使用手册》 mind map]]></content>
      <categories>
        <category>读书记</category>
      </categories>
      <tags>
        <tag>Mind Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大唐叛逆记]]></title>
    <url>%2F2016%2F11%2F19%2F%E5%A4%A7%E5%94%90%E5%8F%9B%E9%80%86%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我喉咙干燥，也不愿发声，听天由命 我来寻找的是高贵的朋友，锦绣的前程 ——木心《伪所罗门书》 小絮叨懒癌晚期的某人终于在11月下旬敲下了十一游记的第一个字。所幸时间隔得也不算太久，希望记忆力奇差的我没有忘光其中的细节。 种种原因，决定去西安的时候已经是9月27日了，花了一个下午的时间敲定了路线。 旅行不能怕麻烦。旅行的意义本就是在循规蹈矩的生活中注入一剂催化剂，每个躁动的灵魂都渴望新鲜感。渴望地理环境上的改变能唤起一些内心中将死的东西。渴望一场或浪漫或刺激的邂逅。渴望远眺一座不知名的山。渴望遇见一个触动心灵的人。 当列车伴着报站声启动，当清风摇曳山谷，当妖冶的霓虹灯闪烁，当各色各样的方言穿梭耳畔······ 你就知道，你的旅程，开始了。 烟台 ▲ 烟台站 这次旅行完全是轻装上阵，一个挎包，几件衣服，一包洗漱用品，单反也没拎，颇有点出门逛街的感觉。 ▲ 烟台站 10.2 从烟台出发。刚下完雨，空气还是湿的，深吸一口，胸腔喉咙里都是微甜的味道。离上车的时间还早，在麦叔叔点了一个套餐，掏出kindle，打发时间。 洛阳 离歌且莫翻新阕，一曲能教肠寸结。直须看尽洛阳花，始共春风容易别。 坐了十几个小时的火车，中转郑州，抵达洛阳。 十三朝古都，名字好听，在河南——这基本就是我对洛阳的全部印象。 很多时候，我们对一个城市了解都是由一些零碎的信息拼凑起来的。教科书，网络，别人的言谈——这些间接的信息会在我们的脑海里不断汇集，最后打下烙印。这些烙印有好有坏，不过终是变成了我们思维中的一部分。而旅行，正是打破这一惯性思维的行为。 所见所闻所感比所有的道听途说都来的真实。你会发现你遇到的东北人不都是会打架的，河南人很真挚，南京人也能分清nl。 世界不再是你想象中的模样，它就在你眼前，无比鲜活。 洛阳的傍晚 ▲ 洛阳龙门站 10.3 下午6时抵达洛阳龙门高铁站。下站人不多，全然没有我想象中十一“该有”的样子。 ▲ 落日 傍晚的落日，真美，就像洛阳这座城市，温暖而内敛。 溜溜达达地走出车站，转了一圈，没找到打出租的地方，又绕回高铁站，干脆坐了公交，K75路，6站地。 洛阳的公交站点很有特点，都是路口的名字，像厚载门街关林路口，厚载门街翠云路口，厚载门街牡丹大道路口…… 洛龙区应该是新开发的区，没有历史的痕迹，都是大高楼，人也不多，道路都很干净。 ▲ 秘制鸡丝面 坐了一天的火车，浑身乏累，所以下楼觅了个食之后就回来洗澡睡觉了。 洛阳的街10.4 洗漱之后退了房，依旧75路向河科大进发，寻找小伙伴。小伙伴是初高中同校的同学，一个搞播音的工科男，很swag，和我一样很跨界。 我们在他学校转一圈，校园是老校区，很有历史感，临街就是法国大梧桐树，有5、6层高，十月，叶子还没黄透，一阵风吹过来，扫过几片，簌簌作响。 到了吃中饭的时间，小伙伴亮出了他的小绵羊，载着我，开始了洛阳一日环游。 当天洛阳很热，有将近30度，太阳灼烤着，像要把人晒化掉。秋老虎名不虚传。不过幸亏我们有小绵羊，坐上去一秒上天堂，简直不要更！美！好！ 第一站，锅贴烧麦小笼包！ ▲ 锅贴烧麦小笼包 一家老店，人很多，中午热热闹闹的，很有烟火气。小伙伴很贴心的把每样都点了一份，所以每个都尝了尝。炒鸡好吃。 洛阳的景 ▲ 洛阳老街 丽景门 吃完午饭，去火车站换了票，到丽景门的时候是下午，想来晚上应该会更美。 ▲ 十字街 ▲ 鼓楼 洛阳的鼓楼不大。没有西安的鼓楼那么气势恢宏，但依然有历史的沉重感。（一抹墙皮就哗哗往下掉··· ▲ 明堂&amp;天堂 武则天登基的宫殿。她执政的15年，几乎都是在洛阳度过的。不过明堂给人感觉修复得过多，没甚么历史感。一进门就是跑男的宣传，商业化过重。明堂里主要还是关于唐朝文化的介绍，融入了很多科技的元素，比如用VR看洛阳城，知识竞答上状元榜等等。 ▲ 天堂门前的祈福地 就在天堂门楼逛了一圈，懒癌发作，没进去看。 出来之后，和小伙伴去了凯旋门，吃了晚饭，像肉夹馍一样的东西，具体名字，我不记得了······然后，打车，回到龙门高铁站，困到坐着睡了一觉。 西安 长安大道连狭斜，青牛白马七香车。玉辇纵横过主第，金鞭络绎向侯家。龙衔宝盖承朝日，凤吐流苏带晚霞。百丈游丝争绕树，一群娇鸟共啼花。 西安，古称“长安”，简称“秦”。讲中国地理的时候总会提到一条什么都管的分界线——秦淮一线。秦即秦岭，横亘在中国内陆的腹部地区。由于古代秦人和秦帝国的威名，且伫立于秦国之南，所以谓之“秦”岭。 西安给我的第一印象，应该就是泡馍，凉皮，肉夹馍了。 到西安北站的时候已经是晚上十点了，北站特别大，好半天才找到出口。 城墙你爱这里城墙，古墓，长歌，蔓草里开野花朵。 ——林徽因《城楼上》 ▲ 登城墙 10.5 和小伙伴们在政协大酒会合后，睡了一个饱觉。第二天出门之前犹豫了好久要不要带伞，最后还是因为懒癌发作，没带伞就出门了。结果——刚上城墙就被雨拍在了上面······ ▲ 城墙转角 一路淋雨一路照。雨不小，走了一个小时，几乎都淋透了。所幸天气还不是那么冷。路上咕咚勾搭了一个日本大叔，我们用尽毕生所学的日语和他唠了一路，磕磕巴巴。 ▲ 永宁门 一个多小时后终于找到了一个出口，为了犒劳被大雨拍傻了的我们，我们点了一个全家桶。下雨天，淋雨和全家桶挺配的。 没有带单反的我就犹如拍照少了一条胳膊。以下是灵魂摄手和灵魂模特的城墙照。 ▲ 咕咚&amp;郑小辫 ▲ 崔崔 街景 ▲ 从城墙看西安 城墙之后，第二天去了回民街，因为下雨，所以也没照照片。回民街和南锣鼓巷、芙蓉街都差不多，可能每一座城市都有一条这样的小吃街，只不过名字不同而已。吃了久负盛名的羊肉泡馍，院长和咕咚很喜欢，我和崔崔觉得不甚合口味。 吃了这么多城市，回头看看，好像还是我大辽宁的东西最好吃。 想来只是口味作祟而已。 ▲ 西安的夜景 西安的夜很静。城墙将这座千年古都包围了起来，登楼远望，闹市风光，秦川景色尽收眼底。在现代文明的挤压下，钟鼓楼依旧熠熠生辉。 最后这次旅行最大的收获应该是遇到了形形色色的人，一路火车转辗，因为这些人，倒也没有那么疲累了。当时买返程票的时候，卧铺已经没有了，不得已买了张硬座。24个小时，我们四个吃吃喝喝玩玩，大家轮着睡，过得也还算快。 这次旅行，西安和我想象的样子不那么相同。也可能是我待得时间短，还没有足够的品味这个城市的魅力。 倒是洛阳，很让我惊喜。安静又内敛，干净又有沉淀。 旅行本身就是一次自我的寻找与碰撞。你来到一座城市，在树荫中缓步穿行，和风拂过你的面颊，口袋里揣着去往下一站地的车票，你不知道下一站会遇到谁，会和谁交谈，一切幸乐都在赋予与被给予之间升华。 热闹过后才安静。]]></content>
      <categories>
        <category>旅人说</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《春天责备》]]></title>
    <url>%2F2016%2F11%2F02%2F%E6%98%A5%E5%A4%A9%E8%B4%A3%E5%A4%87%2F</url>
    <content type="text"><![CDATA[马齿咀嚼青草，星星在黑暗中，咀嚼亡魂。 还没到秋天街就空了街隔着玻璃窗伸手乞讨他想要一个来自远方的脏孩子我举着枪 准星巨大如天 星光下 一千个失眠者列队静默今夜，没有爱情我怜悯老迈的天空 如果我是尸体就该投入明亮的白昼焚烧在阳光下 请你喝一瓶啤酒谈谈春天，然后，告诉你我有多想女人 大鹏克服了九万里天风野马也 尘埃也三千世界的呼吸我宁愿叫云蓬毫无方向的宿命者一直麻雀惊起滴水穿石些许怀疑都是命运羊跑了 有夜行者敲门 我身体就开门 有野猫怀孕 我就是充满鱼腥味的窝]]></content>
      <categories>
        <category>读书记</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刨个坑，埋坛酒]]></title>
    <url>%2F2016%2F10%2F12%2F%E5%88%A8%E4%B8%AA%E5%9D%91%EF%BC%8C%E5%9F%8B%E5%9D%9B%E9%85%92%2F</url>
    <content type="text"><![CDATA[“Life is like spring dream which vanishes without a trace.” I should be ungrateful to the gods if I did not try to put my life down on record. 这几年，碎片化的信息看得太多，脑子里都是支离破碎的东西。12年开始玩微博，这三四年间，写中文超过300字儿的次数用两只手也数得过来。我想着，再这样下去，语言能力离退化成原始人也不远了。上周上语言学的课，芮老师笑说我们作为学语言的学生，语言组织能力还不如中学生，说个主旨改个论文题目都磕磕巴巴，半点没有学语言的样子。我心想，还真是这样。搞翻译的时候也是，常常有心无力，英文原文摆在那儿，意思心里明白得很，翻译出来却经不起一点推敲。年前无意在家中翻到高中写的文章，自己都有点诧异，原来自己曾经文笔也好过，只不过这“一过”过了多久，我还真没脸去说。 最近一段时间，尝试着把微博朋友圈之类的东西都关掉了，有倾诉欲是时候，就拿出纸笔记一记。 说实话，感觉挺棒的。从前刷着这些碎片化的信息，不但浪费时间，而且正面的负面的消息都一股脑的涌进来，好多东西都是被迫接受，厌烦得很。现在停了这些零碎八碎的东西，读书的时间更多了，思考的时间也更多了。心很静，也很满。 《浮生六记》里，沈复在第一章的闺房记乐里写道，东坡云：事如春梦了无痕，苟不记之笔墨，未免有辜彼苍之厚。我想，对抗碎片化的最好办法，就是把自己的生活成篇的纪录下来吧。 白云苍狗，苍狗白衣。 现今挖个坑，埋下一坛酒，待到来年花开时，应该会有一番香气吧。]]></content>
      <categories>
        <category>子不语</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邂逅滇渝——山城与艳遇之都的慢摇滚]]></title>
    <url>%2F2016%2F10%2F12%2F%E9%82%82%E9%80%85%E6%B8%9D%E6%BB%87%E2%80%94%E2%80%94%E5%B1%B1%E5%9F%8E%E4%B8%8E%E8%89%B3%E9%81%87%E4%B9%8B%E9%83%BD%E7%9A%84%E6%85%A2%E6%91%87%E6%BB%9A%2F</url>
    <content type="text"><![CDATA[行 又行 那年的八月 自月初起 行进的火车便没停过 一次次从站台登上 缓过神来，已经进入了中国腹地 夏风飒飒，黄葛树满树翠绿 连天都是深蓝色的 阳光不只温暖甚至刺眼 旅行，将那些伤痛都鄙夷化了吧 市街的喧嚣里，一切内心的声音都渐渐变小 信鸽俯冲着扑来 我所等待的，正是这样一封来信 重庆 曾经沧海难为水， 除却巫山不是云。 取次花丛懒回顾， 半缘修道半缘君。 ——元稹 《离思》 想到重庆，不知为何，第一时间映在我脑海里的，就是这首诗。唐宋时期，夔州控制下的长江三峡已是中国南方最繁盛的交通走廊，而夔州之山就是现今的巫山。巫山地处三省交界，主峰便位于重庆境内。 重庆是我从高中时就向往的城市了，也许是因为在大东北生活了二十年，平原的地貌形态已经镌刻在我的脑子里，无法想象重庆的“360度立体全方位超现实魔幻主义建筑风格”会是什么样的——“坐公交车犹如过山车”，“坐一站地愣是翻了一座山”，“用百度地图定位发现自己在江中”，“你永远不知道在重庆下个转角会遇到什么”，“1楼、4楼、12楼都有出口到马路”···去了重庆，你会发现，这些话真的所言非虚。 ▲ 重庆轻轨 一路上溜溜达达，到重庆北站的时候已经是8月2号了。重庆不愧是“四大火炉”之一，8月还正是重庆最热的时候，一下火车，一股热气就扑面而来，感觉整个人都被包裹在潮湿中。 在重庆定的住宿是公寓型民宿，地点比较好，紧靠日月光广场，轻轨2号线可以直达。说到交通，重庆地铁、轻轨并行，地铁速度稍快，最高能达到每小时100km，轻轨则在80左右。因为考虑到重庆地形过于复杂的问题，成本比较高，所以很多情况下都是首选轻轨。 重庆的轻轨坐起来特别刺激。坐在上面，你会穿过有人居住的楼房，驶过滚滚的长江，行于山谷之间，川渝美景尽收眼底。 重庆 · 街景 ▲ 擎天楼 重庆放眼望去都是30层以上的高楼大厦。看不见天空。映在长江上的是游船，是残垣，是入云的摩天大楼。 ▲ 长江 重庆老城区的建筑都很有历史感，穿梭其中，你会感受到独属于重庆的文化。 重庆棒棒工随处可见，人数也非常庞大，年龄在十几岁到五六十岁不等。他们遍布于重庆街头的每一个角落，码头、车站、商厦，从衣物、砖头到汽车轮胎，一根竹棒，几捆绳子就是全部的劳动工具。去重庆回来后，恰好读了一本书，一位美国记者写的《江城》。文中的river town就是从前的小城涪陵现今重庆的一个地级行政区。在这本书中，笔者也对棒棒工着墨不少，可见棒棒工的历史在重庆已然不短。然现在，三分之二的棒棒工年龄都在五十岁以上，这个号称“民工之卵”的群体也在走向衰亡。 ▲ 指路牌 重庆就像一个大迷宫，还属于超s级难解型的。 在重庆，方向感这种东西等于没有，在其他城市，几乎一个百度地图就能走天下了，但是在重庆，什么地图都不管用，如果你敢跟着百度地图走，估计就离跳进长江不远了。 ▲ 重庆的标志建筑，解放碑 解放碑，是重庆的标志建筑物之一，位于渝中区CBD，有旋梯可达顶端。碑顶有时钟和方向标志。我们也就是在这儿走丢的。从这到住的地方百度地图显示大概要十几分钟步行，我们愣是走了一个小时。后来实在走蒙了想打车，结果司机都不愿意拉我们，说太近了。感觉整个人都被嫌弃了。 重庆 · 食 ▲ 麻辣抄手 麻辣抄手应该算重庆的特色美食之一了。没有找很大的店吃，想来街边的小店应该更有本地特色的风味。这抄手吃起来辣而不油，香而不腻，皮薄馅大，几朵葱花放进去，还有淡淡的清香。 ▲ 麻婆豆腐 这碗麻婆豆腐和在大理的小厨留客吃到的完全不一样。总之吃完这个，我再也不敢说自己能吃辣了。 ▲ 翠云水煮鱼 ▲ 干煸芸豆 上面这三道菜应该算是正宗的川菜了。挑了一家美团上评价不错的店，较场口的味觉系。也是到重庆吃的第一顿饭。听店主说，在夏季，会把原有的比较辣的辣椒换成微辣的辣椒。像翠云水煮鱼里用的辣椒就是国内顶级辣椒，贵州“子弹头”——只香不辣。 口味很好，喜欢吃辣的人不能错过。不过重庆的辣和我印象中吃过的辣完全不同，痛感强烈，吃完感觉嘴巴和脑子和自己都没什么关系了，起来走路也有点蒙，后劲特别大。 重庆 · 大学习惯于在到每个城市后，都去逛一逛它的大学。因为我一直相信，每一所学校都是城市的一部史书，在无声中记载着这个城市的变化。到重庆也是一样，规划路线时便留了半天给大学城。吃完饭，坐着轻轨，去重庆大学城转了一圈。放假期间，没什么人，包场看了个电影。 ▲ 大学城方向 ▲ 重庆大学·正门 ▲ 脚踏车 ▲ 未知名的小花 重庆属于有武侠梦的侠客，也属于有浪漫心的少女。它泼辣又不失温柔，潇洒又不乏内敛。它以峭拔的姿态守护着独属山城的美。 重庆是一个让人忘不得的城市。它的山川，它的河谷，它的璀璨，它的深邃，你开始只是细细的呷尝着，却又忍不住咀嚼起来，带着力量，试图将这一切吞入腹中，永不相忘。 昆明 波光潋滟三千顷，莽莽群山抱古城。 四季看花花不老，一江春月是昆明。 ——《昆明行记》 ▲ 昆明站 在火车上睡了一晚，8月5号清晨，到了昆明。 来之前对昆明的印象并不是很好，曾经一度被“昆明火车站”事件洗脑得很严重。所以也没有定停留昆明的时间，想着早上5点到昆明，晚上7点去大理，中间的时间也够在昆明逛逛的了。不过，到了昆明，我只想对当初定路线的自己说，孩子，你还是太肤浅、太天真。 昆明这个城市要比我想象的好得多，原谅用了“好”这个泛泛的词，因为停留昆明的时间太短，确实也没有机会更多的体会这个城市的美。 ▲ 别墅青旅 昆明是这次旅行唯一现定住宿的一站。不过很幸运，定到了一家在别墅区、离滇池很近的青旅。乘双层巴士到住宿处大概1一小时左右，到青旅整顿了一下之后，我们就租了自行车向民族村进发。 ▲ 小花 骑行去民族村时，遇到的路边的小花。觉得很漂亮，就顺手拍了下来。 ▲ 民族村正门 昆明的天特别蓝，空气也很清新。我们跟着百度地图，一路骑到了民族村。 ▲ 大象 民族村位于滇池国家旅游度假区内，背靠森林公园，紧邻“高原明珠”滇池。 众所周知，云南是我国少数民族最多的省份，全省少数民族人口占总人口的近三分之一。民族村便是少数民族小聚居的一个缩影，将少数民族文化风情、音乐舞蹈、宗教信仰浓缩于湖光山色之中。 我们到的当天民族村内还挂着“火舞民族村，狂欢滇池夜”的条幅，想来火把节应该是刚刚过去不久。 大理 下关风，上关花，苍山雪，洱海月。谓之“风花雪月”。 大理啊，真是一个听名字就透着浪漫的地方。听说大理是小清新的必到地之一，作为一个伪清新实重口的女青年，我决定来大理看看，“风花雪月”是什么样子的。 大理作为一个18线开外的旅游城市，交通和省会城市昆明简直是没法比。除了大理古城之外，市区看起来也相对来讲比较落后。清晨到达大理站，坐了一个半小时的公交，终于颠到了古城区。 大理 · 建筑 ▲ 路牌 大理古城东门进入的第一个路口。 ▲ 白族民居 ▲ 白族民居 白族民居多为二层楼房，三开间，筒板瓦盖顶，前伸重檐，呈前出廊格局。墙脚、门头、窗头、飞檐等部位用刻有几何线条和麻点花纹的石块，墙壁常用天然鹅卵石砌筑。墙面石灰粉刷，白墙青瓦，尤耀人眼目。 ▲ 写着风花雪月的飞檐 ▲ 金花木屋 大理的民居建筑特别的漂亮，很有本地的特色。 大理 · 明信片 ▲ 明信片小店 来大理的第二天。在古城里各种扫荡。明信片儿，寄出去了二十几张。 下午下了瓢泼大雨，得亏带了雨衣。积水到了小腿肚，我们不管不顾地披着雨衣在里面淌啊淌···就着雨水蘸邮票，把心情邮塞进了邮筒里。 ▲ 手写明信片 这是某橙写的。 大理 · 苍山洱海提到大理，最不能忘的应该就是苍山洱海了。古城区内遍是去苍山洱海的小旅游团，每走一百米就会有人来跟你搭讪。因为古城区离苍山洱海不是特别近，所以我们也订了一个团，跟着大巴走。 ▲ 苍山索道 坐这个还是有点小恐高。不过风景特别的美，也让人顾不上害怕了。 ▲ 姻缘锁 苍山顶的姻缘锁。听说相爱的人把彼此锁在这儿，就永远不会分离。 不知道是不是真的，但有一点可以肯定——能爬上来的情侣，体力一定都特别好。因为实在是太陡了！太高了！太累了！爬到半山腰的时候，有个可以下山的出口，工作人员在那喊，老人孩子爬不动的可以从这边下去了啊。我刚要往下山的方向迈出一只脚，就看一个60多岁精神矍铄的老大爷往上爬去了，我不得不颤颤巍巍的又把那只脚收了回来··· ▲ 苍山洱海 不过爬到山顶了，景色确实特别的美。 ▲ 天龙洞天龙八部取景拍摄的地方。 ▲ 洱海游船爬完苍山后，又坐着游船在洱海上转了一圈。 ▲ 大理的云 ▲ 远山 ▲ 洱海 远山如黛，静水微澜。山风猎猎，海浪沧沧。 这就是大理，一个能让人停住脚步的城市。苍山洱海之间，心安即是归途。 丽江 翠色山峦下， 商居掩古城。 花溪迎曲巷， 岁月久悠增。 丽江，艳遇之都。无数人从大城市逃离，来到这里，找寻自己。许许多多的人把丽江看作是身心与灵魂的栖息地。 丽江人口以纳西人为主，而古城的纳西名称叫“巩本知”，“巩本”为仓廪，“知”为集市，可知丽江古城曾是仓廪集散之地。 束河古镇 ▲ 客栈 丽江的第一站是束河古镇。到丽江的时候，又下了一场雨，雷雨浥尘，暑气一夕尽消。 束河远比我想的要安静，白天几乎没甚么人，只有几条小狗爬在路边。到了束河，你会连呼吸都不自觉慢下来。空气很清新，深吸一口，再缓缓吐出来，都觉得很幸福。 ▲ 客栈 束河满地都是客栈，古风古韵，各有特色。 ▲ 马车 偶尔会有一辆马车驶过来，让人想起木心一首很有名的诗: 记得早先少年时，大家诚诚恳恳，说一句是一句。清早上火车站，长街黑暗无行人，卖豆浆的小店冒着热气。从前的日色变得慢，车、马、邮件都慢，一生只够爱一个人。从前的锁也好看，钥匙精美有样子，你锁了，人家就懂了。 ▲ 猫花园餐厅 肚子饿了，路过一家餐厅，顺道坐下来。 ▲ 萨摩耶 狗也懒得很。 ▲ 四方街 束河古镇和大研古城都有一条“四方街”，不知道是巧合还是什么。 ▲ 酒吧驻唱 路过酒吧一条街，停下轻和一曲。 ▲ 沏茶 买披肩的时候，接待我们的店主的妈妈，是一位很和善的阿姨，买完东西还请我们到隔壁（他们家的茶店）喝茶。阿姨亲手给我们沏茶。茶名叫苍山雪，第一口喝起来很苦，这时候再稍抿一口白水，口腔喉腔里一股淡淡的甜味就散开了。 喝着茶，屋外便是流浪歌手的歌声，和阿姨聊聊束河的风土人情，想着时间可要慢点过去才好。 ▲ 灯 晚上十点多钟回到客栈，老板贴心地给我们留了灯。 ▲ 客栈的院子 束河住宿的地方。客栈不大，两层，店主是一大家子人，养了两只萨摩。 大研古城大研古城是中国历史文化名城之一，也是中国向联合国申报世界文化遗产成功的古城之一，与四川阆中、山西平遥、安徽歙县并称为“保存最为完好的四大古城”。 我们平常说的“丽江古城”实际上就是大研古城。大研古城城内的街道依山傍水修建，铺的大多是红色角砾岩，雨季不会泥泞，干季不会飞灰。街道曲、幽、窄、达，家家流水，错落有致。 据说因为丽江世袭的官宦家姓木，而筑城墙势必如“木”字加框而成“困”，所以丽江古城并没有城墙。 ▲ 酒吧一条街大研和束河比，商业化的气息更浓重了些。 ▲ 光阴的故事 ▲ 静谧 入夜，大雨随时沛然而至我们行向古城深处从古桥至木府，从四方街到五凤楼入市过桥，朝着幽深的胡同小小的祠，流转的水车洋气的声乐、器乐，让人忍不住轻声跟着和的民谣一路全无记忆的路名吃食的香腻味儿争抢着从道路两侧扑出来静立着，头顶没伞，雨一来就汇成了小池潭细细的沙碛溅起来月明如昼 ▲ 风铃 没有城墙，风放肆的拥挤进来，铃铛响了。 最后2015年8月滇渝之行已经过去一年多了，之前一直懒得下笔，偶尔有了兴致却没有写作的地方。最近动笔写了今年十一的游记，索性把去年的旅行也一并回忆下来。有照片，写起来倒也不难，每个照片都有它背后的故事，将他们串联，便就是一次旅行。 这次旅行前期筹划了很久，因为中间要玩5个城市，20几天，所以订酒店订票转接都稍有些麻烦。我和某橙同学分工明确，我负责定票、订酒店、定路线，她负责吃和玩。 做攻略，买旅行用品，准备背包行李，忙活了一个多月，终于在七月的最后一天开始了旅行的第一站。虽然已经精简得不能再精简了，但因为时间不短，而且要去四季如春的云南，所以备了几件外套，再加上旅行必需品，最后汇在一起，俩人的背包大概也得各有15.6斤了。不过后来事实证明，多带衣服真的没错，因为从我们到了云南开始就一直下雨，晚上最冷的时候温度也就十几度。 这次旅行，真是美好遭罪皆有，幸福苦难并行。作为学生穷游，一路火车坐下来真是无聊到崩溃。尤其是回程，从昆明到济南，2200多公里，加上晚点、延迟，我们在火车上待了两天两夜还要多。但是一路上也遇到了很多有趣的人，幽默的大叔，可爱的小孩，搭伴儿的闺蜜，这些形色各异的人为枯燥的火车旅行添加了不少调味剂。 这样的旅行，想来多少次都不会腻。因为风景在变，遇到的人在变，路上的你，也一直在变。]]></content>
      <categories>
        <category>旅人说</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《朱生豪情书》]]></title>
    <url>%2F2016%2F10%2F11%2F%E6%9C%B1%E7%94%9F%E8%B1%AA%E6%83%85%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[听一个男人说这么多的情话，竟也没觉得腻得慌或者矫情。自己并不向往这样的爱情，却依然觉得朱&amp;宋如此美好。想起豆瓣有人评论朱生豪，他短暂的一生只做了两件事，翻译莎士比亚全集和给爱的人写情书。而后者是比前者更伟大的成就。 要是我们两人一同在雨声里做梦，那境界是如何不同，或者一同在雨声里失眠，那也是何等有味。 这里一切都是丑的，风、雨、太阳，都丑，人也丑，我也丑得很。只有你是青天一样可羡。 寄给你全宇宙的爱和自太古至永劫的思念。 做人最好常在等待中，须是一个辽远的期望，不给你到达最后的终点，但一天比一天更接近这目标，永远是渴望，不实现也不摧毁，每天发现新的欢喜，是鼓舞而不是完全的满足。顶好是一切希望完全化为事实，在生命终了前的一秒钟中。 为了你，我也有走向光明的热望，世界不会于我太寂寞。 我是个平凡的人，不像你那么“狂野”，但我厌弃的是平凡的梦。我只愿意凭着这一点灵感的相通，时时带给彼此以慰藉，“像流星的光辉，照耀我疲惫的梦寐，永远存一个安慰，纵然在别离的时候。” 我的快乐即是爱你，我的安慰即是思念你，你愿不愿待我好则非我所愿计及。 临颖不如云，却怨天气好，愿化一面镜子，常常照你笑。 接到你的信，真快活，风和日暖，令人愿意永远活下去。世上一切算得什么，只要有你。 我是，我是宋清如至上主义者。 我一天一天明白你的平凡，同时却一天一天愈更深切地爱你。你如照镜子，你不会看得见你特别好的所在，但你如走进我的心里来时，你一定能知道自己是怎样好法 但愿来生我们终日在一起，每天每天从早晨口角到夜深，恨不得大家走开。 寂寞常是啮着我，唯你能给我感奋。 不要愁老之将至，你老了一定很可爱。而且，假如你老了十岁，我当然也同样老了十岁，世界也老了十岁，上帝也老了十岁，一切都是一样。 我愿意舍弃一切，以想念你终此一生。 所有的恋慕。 你总有一天会看我不起，因为我实在毫无希望，就是胡思乱想的本领，也比从前差得多了，如果不是因为今天是星期五之故，我真不想活。 不骗你，我很爱你，仍旧想跟你在一起做梦。 如果我想要做一个梦，世界是一片大的草原，山在远处，青天在顶上，溪流在足下，鸟声在树上，如睡眠的静谧，没有一个人，只有你我，在一起跳着飞着躲着捉迷藏，你允不允许？因为你不允许我做的梦，我不敢做的。我不是诗人，否则一定要做一些可爱的梦，为着你的缘故。我不能写一首世间最美的抒情诗给你，这将是我终生抱憾的事。我多么愿意自己是个诗人，只是为了你的缘故。 今后再不说诳话欺骗自己了，愿意炼成一个坚强的钢铁样的信心，永远倾向着你，当我疲倦了一切无谓的游戏之后。我不愿说那是恋爱，那自然是比恋爱更纯粹的信念。我愿意懂得“永恒”两字的意义，把悲壮的意味放入平凡的生活里，而做一个虔诚的人。因我是厌了易变的世事，也厌了易变的自己的心情。 我的野心，便是想成为你的好朋友；现在我的野心，便是希望这样的友谊能继续到死时。谢谢你给我一个等待。 上星期日是母亲忌辰，却忘记了，今天查起来才知道已经过去。也是昨天一样的天气，十一年前的那天，人生的悲哀掩上了我，以至于今日。 如果不是那样饥渴地想忆着你，像沉舟者在海中拼命攀住一根漂浮的桅杆一样，我的思想一定会转入无底绝望而黑暗的深渊，我觉得我的生命好像不是属于自己的，非自己所能把握。 不要自寻烦恼，最好，我知道你很懂得这意思。但是在必要的时候，无事可做的时候，不那样心里便是空虚得那样的时候，仍不妨寻寻烦恼，跟人吵吵闹闹哭哭气气都好的，只不要让烦恼生了根。 假如有人问我烦忧的缘故， 我不敢说出你的名字。 上天入地茫无路，我愿你——灵性不泯，挟风雨作伴，与日月同存；我也愿你——酣睡千秋，超然尘俗之外，忘怀古今得失。]]></content>
      <categories>
        <category>读书记</category>
      </categories>
      <tags>
        <tag>书信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《云雀叫了一整天》]]></title>
    <url>%2F2016%2F10%2F11%2F%E4%BA%91%E9%9B%80%E5%8F%AB%E4%BA%86%E4%B8%80%E6%95%B4%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[读木心的诗，你需要懂点历史，懂点地理，懂点文学，中国的外国的，你还得懂点冷幽默…… “我能抗拒任何事物 除了诱惑”（王尔德） 我能抗拒任何诱惑 直到它们被我所诱惑 这里的花都是深紫色的 我倒并不悲伤 只是想放声大哭一场 马车已驶进城里的石砌街道 行人们向我招呼 我答礼 游目贪看那些房屋的顶层 悬挂在墙洞间的铜钟 栖满了密密麻麻的燕子 一忽儿成群飞起 一忽儿啾啾唧唧 我知道它们准备远行 这里的阳光不够温暖 凉风阵阵 黄叶飘零 仿佛听见古老的歌 “当我归来时 啊 我归来时 一切都已成空” 吃美国大兵剩下来的饲料 读俄罗斯悲天悯人的长篇小说 八年离乱熬过去了 人躺着 两脚高搁床档上 满脑子意大利文艺复兴法国印象派 这便是我辈动辄大言不惭的黑色青春 我愿他人活在我身上 我愿自己活在他人身上 这是“知” 我曾经活在他人身上 他人曾经活在我身上 这是“爱” 雷奥纳多说 知得愈多 爱得愈多 爱得愈多 知得愈多 知与爱永成正比 那时的天气也常会连日阴冷 海鸥飞鸣于屋子的上空 事情发生了 又发生 说不得的 除非记忆 记忆就像滚滚浪潮 撞上海湾里的礁石激出巨响 记忆的巨响人们是听不到的 我们以形骸为贽礼 确曾是 蒙昧的智者 喜怒哀乐皆可念 虽然我并未预知 青春是一去不回来的 迎春送春是说说的 春天又不是一个人 我是一个在黑暗中大雪纷飞的人哪 那种夜说长好长 说短诚然太短 那种黎明惫已惫极 猛烈又怎生猛烈 床上早餐吃什么 已经快正午了 总以为一生就这样下去 彼癖而不洁 此洁而不癖 街角的寒风比野地的寒风尤为悲凉 记得早先少年时 大家诚诚恳恳 说一句是一句 清早上火车站 长街黑暗无行人 卖豆浆的小店冒着热气 从前的日色变得慢 车、马、邮件都慢 一生只够爱一个人 从前的锁也好看 钥匙精美有样子 你锁了 人家就懂了 创作是父性的 翻译是母性的 第一个发明刮耳光的人多有才气 懂得树 就懂得贝多芬 我不好斗 只好胜 好事坏事 过后谈起来都很罗曼蒂克 唐诗下酒 宋词伴茶 有的书 读了便成文盲 海上的早晨 好大好大的早晨 你再不来 我要下雪了 蠢 都是资深的 世界是一口钟 敲在任何地方 都会响的 鹰滑翔的时候 是它思想的时候 主啊 兄弟得罪我 原谅他七次够了么 主说 已经不是兄弟了 把寄与他人的希望收回来放在自己身上 倒也温馨 直道相思了无益 且作新狂解旧狂 天鹅谈飞行术 麻雀说哪有这么多的讲究 玩物丧志 其志小 志大者玩物养志 一次又一次觉得 灵智比肉欲要性感得多 你强 强在你不爱我 我弱 弱在我爱你 花的香是形而上的 忽有谈话的欲望 环顾阒无一人 哥德七十四岁犹动情 到底是哥德 我也曾猝倒在洪大的幸福中]]></content>
      <categories>
        <category>读书记</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
</search>
